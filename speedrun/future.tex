\chapter{Related Work and Future Work}
\label{chap:future}
\section{Related Work}
\hightodo{Write related work}

\section{Original Goal}

The original title of this project was ``A Rust-like Typed Assembly Language --
Using affine types to avoid garbage collection''.

The goal of this proposed thesis was to design a Typed Assembly Language based
on linear types. Linear types have been tried before in the context of TAL, in
particular in the 2003 paper ``A linearly typed assembly
language''\cite{ltal}. In the conclusion of this paper, the authors state that the approach
has serious drawbacks in particular with regards to sharing.

I thought it interesting to revisit the idea, since the programming language
Rust\cite{rust} have proven that using a linear type system\footnote{Technically
  Rust uses an affine type system, not a linear one. In this particular case the
  differences are minor and mostly related to usability of the language.} for
memory management is not completely impractical. In particular it does permit
several useful forms of sharing. I found the paper ``Patina: A Formalization of
the Rust Programming Language''\cite{patina} by Eric Reed, and after skimming
it, it was my hope that I could use the same techniques in a TAL.

I changed focus during the project for a number of reasons. One reason was that
the original paper falls short of actually proving soundness; the last part of
the paper mainly consists of conjectures. This was, as one could expect, quite
detrimental to my effort use the same technique in a TAL. Ideally I should have
noticed this before settling on a thesis subject.

However the much bigger issue in my thesis turned out to be implementing
variables and substitutions correctly in Agda using De Bruijn indices. The
implementation of substitutions take up about 25\% of my final code-base
(including the utilities not specifically related to TAL). This is after
rewriting that part several times and removing unused lemmas.

I do not think that this is an issue with Agda, but rather I think that De
Bruijn indices could simply be hard to formalize correctly -- at least they were
to me. This seems consistent with the results from ``An Untrusted Verifier for
Typed Assembly Language''\cite{untrusted}. In the results section, the authors
describe how they encountered similar problems, when they used a similar
approach to formalizing a TAL in Coq.

This meant that I used most of my time simply re-implementing known results in a
different framework.

\section{Future Work}

I think there are a number of ways, one might expand upon the work in this
thesis.

\paragraph{Extending the type system:}
There are several ways in which it would be interesting to extend the type
system. I am particularly interested extending it with linear types, though
other extensions such as sum types or arrays (with run-time checked indices) are
also obvious improvements.

\paragraph{Substitutions:}
The single problem that took the longest time to solve in this thesis was
substitutions with a clear margin. While I think that my solution is possibly
the most obvious solution to the problem, I do not think that it is the only
one, nor do I think that it is necessarily the nicest.

If I were to redo the project, I would probably try to solve this issue in a
different way. I have a couple of different ideas for how to achieve this:

\begin{itemize}
\item One might change the way De Bruijn indices are used. If we for instance
  that $\Delta = \alpha :: \alpha :: \rho :: \nil$ in the current model, then
  the indices would be $0, 1$ and $2$ respectively. One might alternatively use
  the indices $0, 1, 0$. Here the index is no longer the absolute position in
  the list, but instead the position if one only values of the correct type is
  considered.
\item Alternatively one could split the $\Delta$ into two different lists based
  on type. This would likely work in the current model (and possibly be
  equivalent to the above suggestion), but it would likely work differently if
  we included assumptions that depend on other assumptions.
\item One might try to avoid De Bruijn indices all-together by e.g. encoding the
  variables using function.
\end{itemize}

\paragraph{Research the exact relation to STAL:}
It might be interesting to see exactly how much of STAL can be expressed in
\ATAL and vice versa. There is the obvious slack of compound stacks and
exceptions, but besides this I believe that most, if not all of STAL is
expressible in \ATAL. It would be interesting to verify if this is indeed the
case.

\paragraph{Practical infrastructure:}
It would be interesting to try and develop some infrastructure based on the
implementation. There have been experiments in code extraction from Agda to
e.g. Haskell, and it should be possible to use the code in actual
infrastructure.
