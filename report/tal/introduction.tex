This chapter has three parts. First we will formally introduce the concepts of
Typed Assembly Language in an informal setting. We will first give a formal
definition of the same concepts. Finally we will introduce the specific instance
of Typed Assembly Language used in \cite{STAL}.

Note that I have chosen a specific way of presenting Typed Assembly Language,
that lends itself well to formalization. While this approach is not completely
similar to the approach used in \cite{STAL}, I expect that the concepts should
be fairly recognizable.

\section{Informal definition}
\paragraph{The native language} is the language on which the rest of the work is
based, typically a real-world assembler language. It comes with a notion of a
\textbf{native semantics}, defined by an external party. The native semantics
can be thought of as a (possibly multi-valued) function, which maps the current
state of the CPU to the next state of the CPU.

\paragraph{The simplified language} is a simplification of the raw language
along with \emph{simplified semantics} to match it. While the native language
typically deal with a complicated memory model, where there is no real
difference between code and data, pointers and numbers, this is not the case in
the simplified semantics. This simplification serves multiple purposes:

\begin{itemize}
\item The native semantics are typically not written as a formal
  specification. This means that they might contain both under-specified
  behavior in certain corner cases or and very complicated behavior in others,
  e.g. in the case of multi-core architectures.

  By simplifying we avoid both of these problems.
\item The native semantics might contain semantics that are undesirable. For
  instance it might halt or crash when certain actions occur. In our
  simplification we explicitly avoid undesirable in our semantics.

  \textbf{Note:} This means that the semantics are no longer a total relation.
\end{itemize}

\paragraph{The typed language} is an extension of this simplified language, with
the purpose of introducing typing judgments.

I assume that these typing judgments could also be implemented directly on top
of the simplified language, however this is not what was done in \cite{STAL}. I
do not fully know their reasoning behind this, as they do not have the same
level of detail as I do here. However

These typing judgments could
potentially be specified directly on top of the simplified language, however I, this is not
how it is done in the \cite{STAL}.

I assume that

I do not fully know the reason why this is, as they do not bother with as much distingsion as I present here, however I

There are two things to keep in mind, when defining this simplification:

% \begin{itemize}
% \item The

% This means that our simplified semantics are no longer a total
% relation.



%   well-defined in certain cases or perhaps just have very complicated semantics
%   that are hard to model. The second is that we would like to ex

\section{Formal Definition}

\section{STAL}

% In this chapter we will introduce the concept of a Typed Assembly Language,
% specifically how it relates to a pure assembly language, how one designs it, and
% what it achieves.

% Throughout the section, we will assume that we have been given the task of
% designing a type-system for the real-world assembly language similar to
% MIPS. The details of the language does not matter, much and indeed most
% real-world assembler languages (or even some bytecode languages) could have been
% chosen instead. We choose MIPS primarily to have an easier comparison with existing

%   choice of language does not matter much, as the same techniques
% should be applicable to other hardware languages, and likely even to many
% bytecode languages. However using the choice of MIPS is advantagous, as it is
% very close to the language used in the next section.

% Before beginning, let us take a step back and look at what we have and we are trying to
% accomplish. We have been

% As stated previously\later[]{Put in reference}, we want to create a type system
% for a low-level language.

% In this section we will assume that we are trying to design a type system for a
% variant of MIPS, specified by an external party. This was chosen, because

%  as a base
% for our study. The actual chosen language does not matter much for the
% discussion at hand, as the same techniques should be applicable to other
% assembler language and likely even to some bytecode languages as well.

% Before we even begin to consider what it would mean to introduce types to an
% assembly languages, let us take a step back and look at the big-picture view.

% What we have is as design specification for the CPU in question. This design
% specification consist roughly of the following:

% \begin{itemize}
% \item Some description of how the state present in the CPU at any given
%   time. For most CPUs this will include at least the RAM, the register file and
%   the program counter.
% \item A partial function mapping the current state to an instruction $\iota$. For most CPUs
% \item A partial function mapping

% \begin{tabular}{lrcl}
% $instructions$ & $\iota$ & ::= & $\mathtt{add}\ \mathtt{r}_d, \mathtt{r}_s, v \mid \mathtt{sub}\ \mathtt{r}_d, \mathtt{r}_s, v \mid \dots$ \\
% \end{tabular}

% \later[inline]{Complete the above and add judgments too}

% It turns out that while the above semantics are very general in
