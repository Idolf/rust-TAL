\section{Step 4: Typing judgments}
\subsection{Judgments for type-like objects}

\fbox{$\valid{\Delta}{\tau}$}
\begin{mathpar}
\infer{\alpha \in \Delta}{\valid{\Delta}{\alpha}} \and
\infer{ }{\valid{\Delta}{\mathtt{int}}} \and
\infer{ }{\valid{\Delta}{\mathtt{ns}}} \and
\infer{\valid{\Delta' ++ \Delta}{\Gamma}}{\valid{\Delta}{\forall[ \Delta' ] \Gamma}} \and
\infer{\valid{\Delta}{\tau_1^{\phi_1}} \and \dots \and \valid{\Delta}{\tau_n^{\phi_n}}}
      {\valid{\Delta}{\langle \tau_1^{\phi_1}, \dots, \tau_n^{\phi_n} \rangle}}
\end{mathpar}

\fbox{$\valid{\Delta}{\tau^\phi}$}
\begin{mathpar}
\infer{\valid{\Delta}{\tau}}{\valid{\Delta}{\tau^\phi}}
\end{mathpar}

\fbox{$\valid{\Delta}{\sigma}$}
\begin{mathpar}
\infer{\rho \in \Delta}{\valid{\Delta}{\rho}} \and
\infer{ }{\valid{\Delta}{\nil}} \and
\infer{
  \valid{\Delta}{\tau} \and \valid{\Delta}{\sigma}
}{
  \valid{\Delta}{\tau :: \sigma}
}
\end{mathpar}

\fbox{$\valid{\Delta}{\Gamma}$}
\begin{mathpar}
\infer{
  \valid{\Delta}{\sigma} \and
  \valid{\Delta}{\tau_1} \and
  \dots \and
  \valid{\Delta}{\tau_{max}}
}{
  \valid{\Delta}{\{\mathtt{sp} |-> \sigma, \mathtt{r}_1 |-> \tau_1, \dots, \mathtt{r}_{max} |-> \tau_{max}\}}
}
\end{mathpar}

\subsection{Subtype-judgments for type-like objects}
\fbox{$\subtype{\Delta}{\tau}{\tau}$}
\begin{mathpar}
\infer{\alpha \in \Delta}{\subtype{\Delta}{\alpha}{\alpha}} \and
\infer{ }{\subtype{\Delta}{\mathtt{int}}{\mathtt{int}}} \and
\infer{ }{\subtype{\Delta}{\mathtt{ns}}{\mathtt{ns}}} \and
\infer{
  \subtype{\Delta' ++ \Delta}{\Gamma_2}{\Gamma_1}
}{
  \subtype{\Delta}{\forall[\Delta'] \Gamma_1}{\forall[\Delta'] \Gamma_2}
} \and
\infer{
  \subtype{\Delta}{\tau_1^{\phi_1}}{\tau'_1{}^{\phi_1'}} \and
  \dots \and
  \subtype{\Delta}{\tau_n^{\phi_n}}{\tau'_n{}^{\phi_n'}}
}{
  \subtype{\Delta}
          {\langle \tau_1^{\phi_1}, \dots, \tau_n^{\phi_n} \rangle}
          {\langle \tau'_1{}^{\phi'_1}, \dots, \tau'_n{}^{\phi'_n} \rangle}
}
\end{mathpar}

\fbox{$\subtype{}{\phi}{\phi}$}
\begin{mathpar}
\infer{ }{\subtype{}{\mathtt{init}}{\mathtt{init}}} \and
\infer{ }{\subtype{}{\phi}{\mathtt{uninit}}}
\end{mathpar}

\fbox{$\subtype{\Delta}{\tau^\phi}{\tau^\phi}$}
\begin{mathpar}
\infer{
  \valid{\Delta}{\tau} \and
  \subtype{}{\phi}{\phi'}
}{
  \subtype{\Delta}{\tau^{\phi}}{\tau^{\phi'}}
}
\end{mathpar}

\fbox{$\subtype{\Delta}{\sigma}{\sigma}$}
\begin{mathpar}
\infer{\rho \in \Delta}{\subtype{\Delta}{\rho}{\rho}} \and
\infer{ }{\subtype{\Delta}{\nil}{\nil}} \and
\infer{
  \subtype{\Delta}{\tau}{\tau'} \and
  \subtype{\Delta}{\sigma}{\sigma'} \and
}{
  \subtype{\Delta}{\tau :: \sigma}{\tau' :: \sigma'}
}
\end{mathpar}

\fbox{$\subtype{\Delta}{\Gamma}{\Gamma}$}
\begin{mathpar}
\infer{
  \subtype{\Delta}{\sigma}{\sigma'} \and
  \subtype{\Delta}{\tau_1}{\tau_1'} \and
  \dots \and
  \subtype{\Delta}{\tau_{max}}{\tau_{max}'}
}{
  \subtype{\Delta}
          {\{\mathtt{sp} |-> \sigma, \mathtt{r}_1 |-> \tau_1, \dots, \mathtt{r}_{max} |-> \tau_{max}\}}
          {\{\mathtt{sp} |-> \sigma', \mathtt{r}_1 |-> \tau_1', \dots, \mathtt{r}_{max} |-> \tau_{max}'\}}
}
\end{mathpar}

\subsection{Judgments for value-like objects}

\begin{itemize}
\item $\theta : a$ means that $\theta$ is a replacement for the variable $a$
  (i.e. it is of the form $x / a$ for some suitable $x$).
\item $\Theta : \Delta$ means are replacements for all the variables inside
  $\Delta$ (in the same order). Furthermore the first replacement is allowed
  to use the variables present in later replacements.
\item $\Psi_g, \Delta, \Gamma |- \high{\iota} : \Gamma'$. This means that if
  we run the instruction $\high \iota$ with registers of type $\Gamma$ and
  globals of type $\Psi_g$, then we can be certain that the registers will be
  of type $\Gamma'$ afterwards (though this might not be the most specific
  type). Furthermore both $\Gamma, \Gamma'$ and $\high \iota$ are allowed to
  use the variables in $\Delta$ (though these will of course have to be
  replaced before it is actually possible to run the instruction).
\item For the remainder, $x : y$ means the obvious: $x$ is an object that can be
  interpreted as having the type $y$.
\end{itemize}

\fbox{$\ofinstantiation{\Delta}{\theta}{a}$}
\begin{mathpar}
\infer{
  \alpha \notin \Delta \and
  \valid{\Delta}{\tau}
}{
  \ofinstantiation{\Delta}{\tau / \alpha}{\alpha}
} \and
\infer{
  \rho \notin \Delta \and
  \valid{\Delta}{\sigma}
}{
  \ofinstantiation{\Delta}{\sigma / \rho}{\rho}
}
\end{mathpar}

\fbox{$\ofinstantiations{\Delta}{\Theta}{\Delta}$}
\begin{mathpar}
\infer{ }{
  \ofinstantiations{\Delta}{\nil}{\nil}
} \and
\infer{
  \ofinstantiation{\Delta' ++ \Delta}{\theta}{a} \and
  \ofinstantiations{\Delta}{\Theta}{\Delta'}
}{
  \ofinstantiations{\Delta}{\theta :: \Theta}{a :: \Delta'}
}
\end{mathpar}

\fbox{$\ofwval{\Psi_g,\Psi_h}{\high w}{\tau}$}
\begin{mathpar}
\infer{
  \Psi_g[\ell_g] = \tau_1 \and
  \subtype{\nil}{\tau_1}{\tau_2}
}{
  \ofwval{\Psi_g,\Psi_h}{\mathtt{globval}\ \ell_g}{\tau_2}
}\and
\infer{
  \Psi_h[\ell_h] = \tau_1 \and
  \subtype{\nil}{\tau_1}{\tau_2}
}{
  \ofwval{\Psi_g,\Psi_h}{\mathtt{heapval}\ \ell_h}{\tau_2}
}\and
\infer{ }{\ofwval{\Psi_g,\Psi_h}{\mathtt{int}\ i}{\mathtt{int}}} \and
\infer{ }{\ofwval{\Psi_g,\Psi_h}{\mathtt{uninit}}{\mathtt{ns}}} \and
\infer{
  \ofwval{\Psi_g,\Psi_h}{\high w}{\forall[\Delta_1]\Gamma_1} \and
  \ofinstantiations{\Delta_2}{\Theta}{\Delta_1} \and
  \subtype{\Delta_2}{\Gamma_2}{\Gamma_1[\Theta]} \\
  \text{($\Gamma_1[\Theta]$ should be interpreted as recursively running substitutions inside $\Theta$ on $\Gamma_1$one by one)} \\
}{
  \ofwval{\Psi_g,\Psi_h}{\Lambda\ \Delta_2 \cdot \high w[\Theta]}{\forall[\Delta_2]\Gamma_2}
}
\end{mathpar}

\fbox{$\ofwvaln{\Psi_g,\Psi_h}{\high w}{\tau^\phi}$}
\begin{mathpar}
\infer{
  \valid{\nil}{\tau}
}{
  \ofwvaln{\Psi_g,\Psi_h}{\mathtt{uninit}}{\tau^{\mathtt{uninit}}}
} \and
\infer{
  \ofwval{\Psi_g,\Psi_h}{\high w}{\tau}
}{
  \ofwvaln{\Psi_g,\Psi_h}{\high w}{\tau^{\mathtt{init}}}
}
\end{mathpar}

\fbox{$\ofvval{\Psi_g,\Delta,\Gamma}{\high v}{\tau}$}
\begin{mathpar}
\infer{ }{
  \ofvval{\Psi_g,\Delta,\Gamma}{\mathtt{reg}\ r}{\Gamma[r]}
}\and
\infer{
}{
  \ofvval{\Psi_g,\Delta,\Gamma}{\mathtt{globval}\ \ell_g}{\Psi_g[\ell_g]}
}\and
\infer{ }{\ofvval{\Psi_g,\Delta,\Gamma}{\mathtt{int}\ i}{\mathtt{int}}} \and
\infer{
  \ofvval{\Psi_g,\Delta,\Gamma}{\high v}{\forall[\Delta_1]\Gamma_1} \and
  \ofinstantiations{\Delta_2 ++ \Delta}{[\Theta]}{\Delta_1} \and
  \Gamma_2 = \Gamma_1[\Theta] \\
  \text{($\Gamma_1[\Theta]$ should be interpreted as recursively running substitutions inside $\Theta$ on $\Gamma_1$one by one)} \\
}{
  \ofvval{\Psi_g,\Delta,\Gamma}{\Lambda\ \Delta \cdot \high v[\Theta]}{\forall[\Delta_2]\Gamma_2}
}
\end{mathpar}

\fbox{$\ofhval{\Psi_g,\Psi_h}{\high h}{\tau}$}
\begin{mathpar}
\infer{
  \ofwvaln{\Psi_g,\Psi_h}{\high w_1}{\tau_1^{\phi_1}} \and
  \dots \and
  \ofwvaln{\Psi_g,\Psi_h}{\high w_n}{\tau_n^{\phi_n}}
}{
  \ofgval{\Psi_g,\Psi_h}{\langle \high w_1, \dots, \high w_n \rangle}{\langle \tau_1^{\phi_1}, \dots, \tau_n^{\phi_n}\rangle}
}
\end{mathpar}

\fbox{$\ofheap{\Psi_g}{H}{\Psi_h}$}
\begin{mathpar}
\infer{
  \ofhval{\Psi_g,\Psi_h}{\high h_1}{\tau_1} \and
  \dots \and
  \ofhval{\Psi_g,\Psi_h}{\high h_n}{\tau_n} \and
  \Psi_h = \{\ell_{h,1} |-> \tau_1, \dots, \ell_{h,n} |-> \tau_n\}
}{
  \ofheap{\Psi_g}{\{\ell_{h,1} |->  \high h_1, \dots, \ell_{h,n}  |->  \high h_n\}}{\Psi_h}
}
\end{mathpar}

\fbox{$\ofstack{\Psi_g,\Psi_h}{\high S}{\sigma}$}
\begin{mathpar}
\infer{ }{\ofstack{\Psi_g,\Psi_h}{\nil}{\nil}} \and
\infer{
  \ofword{\Psi_g,\Psi_h}{\high w}{\tau} \and
  \ofstack{\Psi_g,\Psi_h}{\high S}{\sigma}
}{
  \ofstack{\Psi_g,\Psi_h}{\high w :: \high S}{\tau :: \sigma}
}
\end{mathpar}

\fbox{$\ofregister{\Psi_g,\Psi_h}{\high R}{\Gamma}$}
\begin{mathpar}
\infer{
  \ofstack{\Psi_g,\Psi_h}{\high S}{\sigma} \and
  \ofwval{\Psi_g,\Psi_h}{\high w_1}{\tau_1} \and
  \dots
  \ofwval{\Psi_g,\Psi_h}{\high w_{max}}{\tau_{max}} \and
}{
  \ofregister{\Psi_g,\Psi_h}{\{\mathtt{sp} |->  \high S, \mathtt{r}_1 |->  \high w_1, \dots, \mathtt{r}_{max} |->  \high w_{max}\}}{\{\mathtt{sp} |-> \sigma, \mathtt{r}_1 |-> \tau_1, \dots, \mathtt{r}_{max} |-> \tau_{max}\}}
}
\end{mathpar}

\fbox{$\ofinstruction{\Psi_g, \Delta, \Gamma}{\high \iota}{\Gamma'}$}
\begin{mathpar}
\infer{
  \Gamma[r_b] = \mathtt{int} \and
  \ofvval{\Psi_g, \Delta, \Gamma}{\high v}{\mathtt{int}}
}{
  \ofinstruction{\Psi_g, \Delta, \Gamma}
    {\mathtt{add}\ r_a, r_b, \high v}
    {\Gamma[r_a |-> \mathtt{int}]}
} \and
\infer{
  \Gamma[r_b] = \mathtt{int} \and
  \ofvval{\Psi_g, \Delta, \Gamma}{\high v}{\mathtt{int}}
}{
  \ofinstruction{\Psi_g, \Delta, \Gamma}
    {\mathtt{sub}\ r_a, r_b, \high v}
    {\Gamma[r_a |-> \mathtt{int}]}
} \\
\infer{
  \sigma = \overbrace{\mathtt{ns} :: \dots :: \mathtt{ns}}^n :: \Gamma[\mathtt{sp}]
}{
  \ofinstruction{\Psi_g, \Delta, \Gamma}
    {\mathtt{salloc}\ n}
    {\Gamma[\mathtt{sp} |-> \sigma]}
} \and
\infer{
  \Gamma[\mathtt{sp}] = \overbrace{\tau_1 :: \dots :: \tau_n}^n :: \sigma
}{
  \ofinstruction{\Psi_g, \Delta, \Gamma}
    {\mathtt{sfree}\ n}
    {\Gamma[\mathtt{sp} |-> \sigma]}
} \and
\infer{
  \Gamma[\mathtt{sp}] = \sigma
}{
  \ofinstruction{\Psi_g, \Delta, \Gamma}
    {\mathtt{ld}\ r, \mathtt{sp}(n)}
    {\Gamma[r |-> \sigma[n]]}
} \and
\infer{
  \Gamma[r_b] = \langle \tau_1^{\phi_1}, \dots, \tau_n^{\mathtt{init}}, \dots\rangle \and
}{
  \ofinstruction{\Psi_g, \Delta, \Gamma}
    {\mathtt{ld}\ r_a, r_b(n)}
    {\Gamma[r_a |-> \tau_n]}
} \and
\infer{
  \Gamma[r] = \tau \and
  \Gamma[\mathtt{sp}] = \sigma
}{
  \ofinstruction{\Psi_g, \Delta, \Gamma}
    {\mathtt{st}\ \mathtt{sp}(n), r}
    {\Gamma[\mathtt{sp} |-> \sigma[n |-> \tau]]}
} \and
\infer{
  \Gamma[r_a] = \langle \tau_1^{\phi_1}, \dots, \tau_n^{\phi_i}, \dots \rangle \and
  \Gamma[r_b] = \tau_n' \and
  \subtype{\Delta}{\tau_n'}{\tau_n}
}{
  \ofinstruction{\Psi_g, \Delta, \Gamma}
    {\mathtt{st}\ r_a(n), r_b}
    {\Gamma[r_a |-> \langle \tau_1^{\phi_1}, \dots, \tau_n^{\mathtt{init}}, \dots, \rangle]}
} \and
\infer{
  \valid{\Delta}{\tau_1} \and
  \dots \and
  \valid{\Delta}{\tau_n}
}{
  \ofinstruction{\Psi_g, \Delta, \Gamma}
    {\mathtt{malloc}\ r, \langle \tau_1, \dots, \tau_n \rangle}
    {\Gamma[r |-> \langle \tau_1^{\mathtt{uninit}}, \dots, \tau_n^{\mathtt{uninit}}\rangle]}
} \and
\infer{
  \ofvval{\Psi_g, \Delta, \Gamma}{\high v}{\tau}
}{
  \ofinstruction{\Psi_g, \Delta, \Gamma}
    {\mathtt{mov}\ r, \high v}
    {\Gamma[r |-> \tau]}
} \and
\infer{
  \Gamma[r] = \mathtt{int} \and
  \ofvval{\Psi_g, \Delta, \Gamma}{\high v}{\forall[ \nil ] \Gamma'} \and
  \subtype{\Delta}{\Gamma}{\Gamma'}
}{
  \ofinstruction{\Psi_g, \Delta, \Gamma}
    {\mathtt{beq}\ r, \high v}
    {\Gamma}
}
\end{mathpar}

\fbox{$\ofinstructions{\Psi_g, \Delta, \Gamma}{\high I}$}
\begin{mathpar}
\infer{
  \ofinstruction{\Psi_g, \Delta, \Gamma}{\high \iota}{\Gamma'} \and
  \ofinstructions{\Psi_g, \Delta, \Gamma'}{\high I}
}{
  \ofinstructions{\Psi_g, \Delta, \Gamma}{\high \iota ; \high I}
} \and
\infer{
  \ofvval{\Psi_1, \Delta, \Gamma}{\high v}{\forall[ \nil ]\Gamma'} \and
  \subtype{\Delta}{\Gamma}{\Gamma'}
}{
  \ofinstructions{\Psi_g, \Delta, \Gamma}{\mathtt{jmp}\ \high v}
} \and
\infer{
}{
  \ofinstructions{\Psi_g, \Delta, \Gamma}{\mathtt{halt}}
}
\end{mathpar}

\fbox{$\ofgval{\Psi_g}{\high g}{\tau}$}
\begin{mathpar}
\infer{
  \valid{\Delta}{\Gamma} \and
  \ofinstructions{\Psi_g, \Delta, \Gamma}{\high I}
}{
  \ofgval{\Psi_g}{\mathtt{code}[\Delta]\Gamma \cdot \high I}{\forall[\Delta]\Gamma}
}
\end{mathpar}

\fbox{$\ofglobs{\high G}{\Psi_g}$}
\begin{mathpar}
\infer{
  \ofgval{\Psi_g}{\high g_1}{\tau_1} \and
  \dots \and
  \ofgval{\Psi_g}{\high g_n}{\tau_n} \and
  \Psi_g = \{\ell_{g,1} |-> \tau_1, \dots, \ell_{g,n} |-> \tau_n\}
}{
  \ofglobs{\{\ell_{g,1} |->  \high g_1, \dots, \ell_{g,n}  |->  \high g_n\}}{\Psi_g}
}
\end{mathpar}

\fbox{$\ofprogramstate{\Psi_g}{\high P}{(\Psi_h,\Gamma)}$}
\begin{mathpar}
\infer{
  \ofheap{\Psi_g}{\high H}{\Psi_h} \\
  \ofregister{\Psi_g,\Psi_h}{\high R}{\Gamma} \and
  \ofinstructions{\Psi_g,\nil,\Gamma}{\high I}
}{
  \ofprogramstate{\high G}{(\high H,\high R,\high I)}{(\Psi_h,\Gamma)}
}
\end{mathpar}

\fbox{$\ofprogram{\highlang}$}
\begin{mathpar}
\infer{
  \ofglobs{\high G}{\Psi_g} \and
  \ofprogramstate{\Psi_g}{\high P}{(\Psi_h, \Gamma)}
}{
  \ofprogram{\running (\high G,\high P)}
} \and
\infer{ }{\ofprogram{\halted}}
\end{mathpar}

\subsection{Notes on the Agda implementation}

The biggest difference from the Agda-implementation\footnote{The relevant files
  are \texttt{Judgments/Types.agda} and \texttt{Judgments/Terms.agda}.} is again
centered around De Bruijn indices.
