\clearpage
\section{The goal of STAL}

Given the newly introduced terminology, it is possible to succinctly state the
goals of STAL\footnote{The original goals of STAL\cite{STAL} were less explicit,
  as they assumed a certain amount of reader familiarity. While the I am not
  able to speak for the original authors, I hope that they would consider this a
  fair rewording.}:

\begin{enumerate}
\item Design a RISC-like simplified assembly language $\mathtt{STAL}_S$.
\item Design a typed assembly language $\mathtt{STAL}$.
\item Prove that the type-system of $\mathtt{STAL}$ is sound.
\item Prove that type-checking for $\mathtt{STAL}$ is decidable.
\item Create a translation from $\mathtt{STAL}$ to $\mathtt{STAL}_S$ and show
  that this translation is a bisimulation when restricted to the well-typed
  fragment of $\mathtt{STAL}$.
\item Create a translation from $\mathtt{STAL}_S$ to a real machine. Ideally one
  would prove that this translation is a bisimulation, however this is not
  possible:
  \begin{itemize}
  \item $\mathtt{STAL}_S$ has unlimited memory, while an actual machine does
    not.
  \item Real machines includes non-deterministic not present in
    $\mathtt{STAL}_S$, as it might receive an interrupt from the world at any
    time.
  \item While $\mathtt{STAL}_S$ exists in a vacuum, the corresponding real-world
    programs will depend on a run-time, and this run-time is typically very hard
    to reason about.
  \item Real-world processors are too complex to model without simplifying
    assumptions, which would have to be quantified.
  \end{itemize}
  So instead of trying to \emph{prove} the existence of a bismulation, we are
  left with \emph{arguing} a weaker form of relation.
\item Show that the type-checking from point 4 is \emph{fast} in practice.
\item Show that the translation from point 5 is \emph{fast} in practice.
\item Show that the translation from point 6 is \emph{fast} in practice.
\item Show that the generated programs are \emph{fast}.
\item Show that $\mathtt{STAL}$ is general enough to allow useful,
  general-purpose code to type-check. In particular, it should be possible to
  translate high-level code into $\mathtt{STAL}$.
\item Show that the translation produces non-malicious code.
\end{enumerate}

There original papers\cite{TAL}\cite{STAL} dealt directly with the design (point
2 and indirectly point 1) and compilation (points 10 and 11). However they
mention most of the remaining points too:

\begin{itemize}
\item Point 3 is postulated and a proof idea is included.
\item The translation of point 5 is simply to drop some annotations.
\item The translation of point 6 includes running an assembler and linking
  against a run-time library.
\item Point 8 is trivial by design.
\item Point 9 is easily achievable assuming a suitable binary representation.
\item Point 12 mostly follows from point 5 and 6, however one would still need
  to show that it is not possible to write malicious code in $\mathtt{STAL}$.
\end{itemize}

In the next chapter, we will address the proofs of 3-5.
