\chapter{\ATAL and \ATALe}
\label{chap:lang}

As stated \cref{sec:goals}, we want to design a secure sandbox, and to do so we
will need to design a Typed Assembly Language and prove soundness for it. In
this chapter we will introduce the two languages in which we will build this
sandbox. We will do this by:

\begin{itemize}
\item Defining \ATAL and \ATALe in terms of their program states.
\item The set of possible program states are defined in terms a Context-Free
  Grammar in our Agda formalization. In our paper definition, we have chosen to
  use some syntax that is not Context-Free for increased readability. As we
  shall see, this is not a problem as there is a trivial correspondence between
  the two presentations.
\item We will present a small-step semantics for the two languages and prove
  that they are related by the erasure property.
\end{itemize}

\section{The System Architecture and Evaluation Model}

[Present the CPU architecture and the evaluation model. Say briefly how to
relates to a real-world CPU.]

\section{Erasure Semantics}

[Define erasure semantics informally and say why they are valuable]

\section{Grammar for \ATALe}
\section{Grammar for \ATAL}
\section{Semantics for \ATAL}
\section{Semantics for \ATALe}
\section{Proof of erasure}

% % Informally
% % this means that the languages are essentially equivalent, however there are two
% % good reasons for introducing it anyways:


% % A fundamental abstraction in \ATAL (and other TAL-based systems) is the
% % basic-block. A basic-block is a collection of instructions with two properties:

% % \begin{itemize}
% % \item There can only be references to the start of a basic-block, not into the
% %   middle of one.
% % \item A basic block will always contain exactly one unconditional jump or halt,
% %   and that is the last instruction of the block.\footnote{Note that it is often
% %     beneficial to weaken this assumption slightly, by also allowing an
% %     \emph{implicit} unconditional jump to the basic-block at the next
% %     address. We will not allow that in our definition, but could easily emulate
% %     it.}
% % \end{itemize}

% % A program-state in \ATAL is a tuple $\langle G, H, R, I \rangle$ consisting of
% % \textbf{global values}, \textbf{heap values}, \textbf{register values} and
% % \textbf{the current basic-block}. In \ATAL a global value is always a
% % type-annotated basic-block, but it could be extended with other global values. A
% % heap value is always a tuple of word-sized values (though it could be a tuple of
% % size 1). In Agda we implement these collections as ordered lists, however other
% % constructions such as dictionaries could be used.

% % The register values is a mapping from register names to a word values -- the
% % only exception is the stack pointer, which is mapped to a stack of word values
% % (again implemented as an ordered list).

% % We will then define a small-step semantics, which is a relation from
% % program-states to program-states.


% % \begin{itemize}
% % \item \ATAL depends on types at run-time for its execution. while \ATALe does
% %   not. Since the two languages are essentially equivalent, one can simply
% %   translate from \ATAL to \ATALe before running the program.
% % \item \ATALe is much simpler than \ATAL. This makes it easier to reason about
% %   any implementation that runs \ATALe-code.
% % \item It makes it possible to experiment with changes to \ATAL without changing
% %   \ATALe or the system that runs \ATALe-code.
% % \end{itemize}
