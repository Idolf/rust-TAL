\chapter{\ATAL and \ATALe}
\label{chap:lang}

As stated in \cref{sec:goal}, we want to design a secure sandbox. To do so we
will design a Typed Assembly Language and prove its soundness. In this chapter
we will introduce the two languages in which we will build this sandbox. We will
do this by:

\begin{itemize}
\item Defining \ATAL and \ATALe in terms of their program states.
\item The set of possible program states are defined in terms of a syntax. In
  our Agda formalization this syntax is specified by a collection of inductive
  data types. In our paper definition, we have chosen to use some slightly more
  advanced syntax for increased readability. As we shall see, this is not a
  problem as there is a trivial correspondence between the two presentations.
\item We will present a small-step semantics for the two languages and prove
  that they are related by the erasure property.
\end{itemize}

The full implications of and reasoning behind having two languages related by
erasure will be discussed later. \Cref{chap:erasure} will discuss some of the
issues along with the proof, while the full reasoning will not be apparent until
\Cref{chap:safesound}. For now we will simply postulate two advantages of this
approach over the alternative of using a single language:

\begin{itemize}
\item By having two languages we are mostly able to separate our type system
  from our model simplification. This would ideally make our presentation
  easier, but it is also an advantage when reasoning about the sandbox
  implementation.
\item This separation also allows one to experiment with different type systems:
  If the experimental type system is sound, decidable and has the erasure
  property, then it can potentially use the same sandbox infrastructure. In fact
  a single sandbox implementation might have multiple type-checkers, if some
  features turn out to be incompatible in the type system.
\end{itemize}

Before formally defining the languages, we will give an informal understanding
of our model by comparing it to real-world CPUs.

\section{Syntax for \ATALe}

Before introducing \ATAL, let us introduce \ATALe. It is both simpler and better
captures the intended meaning of the language. The syntax for \ATALe is
presented in \cref{fig:esyntax}. To understand this syntax, it is useful to
compare it real-world CPUs.

Most real-world CPUs are in essence Von Neumann architectures. In (a simplified
version of) the Von Neumann architecture, one only has memory and registers each
holding some number of machine words. Additionally one has a procedure to fetch,
decode and execute the current instruction from memory by using a
special-purpose register called the instruction pointer. This execution might
change either memory or registers. To run the CPU simply, we repeat the
execution procedure indefinitely.

In this architecture there are only two conceptual abstractions: Machine words
are fixed-width integers and instructions are just decoded machine words. This
simplicity makes it easier to implement and analyze CPU designs, however it
makes hard to analyze programs.

As in the von Neumann architecture \ATALe consists of program states that can
transition to each other. However these states are somewhat more complex, as a
number of new concepts are introduced. Machine words are in our model
represented by \emph{word values}. These are not the simple fixed-width numbers
from the von Neumann architecture, instead there are a number of different
constructions distinguished by a tag. This tag is only present in our model;
when translating to a real-world CPU, the tag will be discarded. All word values
can be copied or overwritten, however other uses depend on the tag:

\begin{itemize}
\item Words tagged with \texttt{int} are numbers and can be used for
  arithmetic.
\item Words tagged with \texttt{globval} are pointers to code. We can use these
  pointers as destination for code branching.
\item Words tagged with \texttt{heapval} are pointers to mutable data. We can
  use these pointers to read or write data.
\item Words tagged with \texttt{uninit} are uninitialized. They occur for
  instance when allocating a new tuple or when allocating space on the
  stack. They cannot be used for anything (besides being copied or overwritten).
\end{itemize}

Another difference is that instructions are no longer machine words decoded at
run-time. Instead they are pre-decoded and are organized into basic blocks. A
basic block is an immutable series of instructions that ends with a \texttt{jmp}
or \texttt{halt} instruction. It should be noted that we have included an
instruction that is not typically encoded directly in the CPU, namely
\texttt{malloc}. When translating to the real-world CPU, this will require
assistance from a memory manager. Since we have not included a
\texttt{free}-instruction, it will also require a garbage collector if we wish
to avoid memory leaks.

The \emph{global collections} are where we store immutable, global data. In our
model there is only one type of global value: code organized into basic
blocks. Our \texttt{globval}-pointers will always point to the beginning of a
global value. Initially this might seem restrictive, as it prevents some forms
of code re-use, but it turns out to not be a problem in practice. If we wanted
to refer to some point in the middle of a basic block, then we could simply
split it and insert an unconditional jump at the end of the first block. We
might even make this jump implicit to avoid wasting space.

\begin{figure}
  {\footnotesize
    \begin{tabular}{lrcl}
      Variables: \\
      \textit{global pointers} & $\ell_{\mathrm{g}}$ \\
      \textit{heap pointers}   & $\ell_{\mathrm{h}}$ \\\\

      Common definitions: \\
      \textit{integer}            & $n$ & ::= & $0, 1, \dots$ \\
      \textit{machine integers}   & $i$ & ::= & $0, 1, \dots, 2^{\mathrm{wordsize}}-1$ \\
      \textit{registers}          & $r$ & ::= & $\mathtt{r}_1 \mid \dots \mid \mathtt{r}_{\mathrm{max}}$ \\\\

      The syntax for \ATALe: \\
      \textit{word values}        & $\simple w$ & ::= & $\mathtt{int}\ i \mid \mathtt{globval}\ \ell_{\mathrm{g}} \mid \mathtt{heapval}\ \ell_{\mathrm{h}} \mid \mathtt{uninit}$ \\
      \textit{small values}       & $\simple v$ & ::= & $\mathtt{int}\ i \mid \mathtt{globval}\ \ell_{\mathrm{g}} \mid \mathtt{reg}\ r$ \\
      \textit{global values}      & $\simple g$ & ::= & $\mathtt{code}\ \simple I$ \\
      \textit{heap values}        & $\simple h$ & ::= & $\mathtt{tuple}\ \langle \simple w, \dots, \simple w \rangle$ \\
      \textit{stacks}             & $\simple S$ & ::= & $\nil \mid \simple w :: \simple S$ \\
      \textit{instructions} & $\simple \iota$ & ::= & $\mathtt{add}\ r, r, \simple v \mid \mathtt{sub}\ r, r, \simple v \mid$ \\
                               &&& $\mathtt{salloc}\ n \mid \mathtt{sfree}\ n \mid$ \\
                               &&& $\mathtt{ld}\ r, \mathtt{sp}(n) \mid \mathtt{ld}\ r, r(n) \mid$ \\
                               &&& $\mathtt{st}\ \mathtt{sp}(n), r \mid \mathtt{st}\ r(n), r \mid$ \\
                               &&& $\mathtt{malloc}\ r,\ n \mid $ \\
                               &&& $\mathtt{mov}\ r, \simple v \mid \mathtt{beq}\ r, \simple v$ \\
      \textit{instruction sequences} & $\simple I$ & ::= & $\simple\iota ; \simple I \mid \mathtt{jmp}\ \simple v \mid \mathtt{halt}$ \\\\

      \textit{global collections} & $\simple G$ & ::= & $\{\ell_{\mathrm{g}} |-> \simple{g}, \dots, \ell_{\mathrm{g}} |-> \simple{g}\}$ \\
      \textit{heap collections}   & $\simple H$ & ::= & $\{\ell_{\mathrm{h}} |-> \simple{h}, \dots, \ell_{\mathrm{h}} |-> \simple{h}\}$ \\
      \textit{register files}     & $\simple R$ & ::= & $\{\mathtt{sp} |-> \simple{S}, \mathtt{r}_1 |-> \simple{w}, \dots, \mathtt{r}_{\mathrm{max}} |-> \simple{w}\}$ \\
      \textit{program states} & $\simple P$ & ::= & $(\simple G, \simple H, \simple R, \simple I)$ \\\\
    \end{tabular}
  }
  \caption{The syntax for \ATALe}
  \label{fig:esyntax}
\end{figure}

We store long-lived, mutable data in the \emph{heap collection}; specifically
our only type of heap value is a tuple of word values. Again we will only allow
pointers to the beginning of objects, so \texttt{heapval}-pointers always point
to an entire tuple. This will prevent some useful programs from being
represented in our model. It should be possible to extend the model to
accommodate this and similar use-cases, however doing so is outside the scope of
this thesis.

The \emph{stack} is used for short-lived, mutable data. There can be no pointers
to the stack; we only reference the stack directly through offsets from the top
of the stack, which is saved in the register \texttt{sp}. Besides reading or
writing through indexing of the stack, we have instructions for allocating and
deallocating word values from the stack.

\emph{Small value} are arguments used as part of some instructions. These
arguments can refer either to registers, constant integers or be code
pointers. This allows us to write e.g.
$\mathtt{add}\ r_a, r_b, \mathtt{reg}\ r_c$ and
$\mathtt{add}\ r_a, r_b, \mathtt{int}\ i$. A small value can be thought of as a
description of how to generate a particular word value when the code is
executed.

Finally we can state that \emph{program states} in \ATALe consists of a global
collection, a heap collection, a register file and the current block. This is
different from the von Neumann architecture, where states are simply some
registers and some memory. While certainly more complicated, one could also
argue that \ATALe is in a sense a specialization of the von Neumann
architecture:

\begin{itemize}
\item Memory have been split up and specialized for different use-cases.
\item A register have been dedicated to the stack. It will always point to the
  top of the stack, and it is in fact the only reference to the stack.
\item The instruction pointer have been similarly specialized. Instead of
  pointer into memory, we hold a reference to the remainder of the current basic
  block.
\end{itemize}


\subsection{Notes on the Agda Implementation}

Our Agda-version of this syntax is implemented in the
\texttt{Judgments/SimpleSyntax.agda}, and it is very close to the above
presentation. Most of the above syntax can be represented directly in Agda using
inductive data types. The exception to this is that we have used dictionaries
and variables drawn from infinite, enumerable sets. Neither of these can be
represented directly in Agda.

We solve these problems by representing the variables and registers using
natural numbers. This means that we can use ordered lists instead of
dictionaries, and ordered lists can be represented directly in Agda. The globals
collection
$\{\ell_{\mathrm{g},0} |-> g_{\mathrm{e},0}, \ell_{\mathrm{g},1} |->
h_{\mathrm{e},1}\}$ could for instance be represented in the Agda-code by the
list $h_{\mathrm{e},0} :: h_{\mathrm{e},1} :: \mathtt{nil}$ in which case we
would have $\ell_{\mathrm{g},0} = 0, \ell_{\mathrm{g},1} = 1$. The other valid
choice would be $h_{\mathrm{e},1} :: h_{\mathrm{e},0} :: \mathtt{nil}$, but in
this case we have $\ell_{\mathrm{g},0} = 1, \ell_{\mathrm{g},1} = 0$.

This difference between the two versions is of no particular importance, and it
exists mostly for readability and to conform with earlier papers (see
\cref{sec:rel-stal}). There are however two interesting consequences of the
differences:

\begin{itemize}
\item It is at this point worth emphasizing that terms that are syntactically
  equal in our paper-notation might not be syntactically equal in the
  Agda-representation (though the reverse direction holds). In fact, we have
  just seen an example where this is the case. Luckily, this difference will
  have no real consequence, as our results does not depend on it.
\item Some of the lemmas proven in the Agda-code will be very hard to even state
  when using the paper notation. This will be particularly noticeable after we
  introduce variable substitution in \ATAL. Luckily these lemmas are not
  themselves particularly interesting; they are simply needed for other
  results. We will mostly bypass this issue by leaving out trivial lemmas and
  stating the non-trivial ones in a slightly informal fashion.
\end{itemize}

\paragraph{A note on equality:}
In the remainder of the report, we will at times talk about equality between
program states or other objects in the grammar. When doing so, we will
exclusively talk about syntactic equality, specifically syntactic equality in
the Agda implementation. Since we are representing variables using natural
numbers and dictionaries as lists, this will be equivalent to equality up to
alpha conversion, but \emph{not} up to changing the order of objects in a
dictionary.

\subsection{Lemmas}
\label{sec:equality}

At this point, we are already able to prove lemmas about our syntax. In the file
\texttt{Lemmas/Equality.agda} we prove this:

\begin{lemma}
  Given two program states $\simple{P}, \simple{P'}$ we can decide whether we
  have $\simple P = \simple{P'}$ or $\simple P \neq \simple{P'}$. Similar
  statements hold for the other syntactic categories (e.g. word values).
\end{lemma}

This lemma is trivial in the sense that it can be proven for any inductively
defined datatype. We still mention it, because it is not automatically derived
in Agda. Since equality is defined as part of the standard library and not the
language, and there is currently no way to automatically derive the
lemma.\footnote{This is not quite true, as there is currently a lot of work
  being done on reflection, meta-programming and tactic systems, each of which
  could potentially implement this lemma automatically. Nevertheless the
  \emph{current} version of the standard library does not allow one to
  automatically derive this lemma.} The naive approach to implementing this
lemma in Agda would use structural induction over both arguments. This has the
disadvantage, that it often results in very long proofs, specifically a
quadratic number\footnote{Quadratic in the number of constructors for the
  datatype.} of lines. We have instead chosen to use a more space-efficient
solution, which involves using an injective function to another datatype. See
\cref{sec:deceq} for more details.

\section{Syntax for \ATAL}

The syntax for \ATAL is presented \cref{fig:syntax} and is very similar to that
of \ATALe. The biggest addition is the type system which is present during the
run-time. This type system includes the parametric polymorphism and subtyping.

Specifically we allow our basic blocks to have parametric polymorphism. The
parameters are specified by the $\Delta$ that is part of global values. This
polymorphism allows us generalize the type code blocks not only over the type of
the registers it accepts, but also the stack.

As an example, consider a basic block which takes four arguments. The first
argument is an integer, while the second and third are references to other basic
blocks. However we wish this basic block to be as general as possible -- it
should not make any assumptions upon the value of the forth argument, but simply
pass it along to the function it wishes to jump to. We have written an example
achieving just this in \cref{fig:parexample}.

\begin{itemize}
\item The \emph{base types} are best thought of as the types of word values and
  small values. It also reused for global values and heap values, though these
  only use a subset of the possible types (specifically function types and tuple
  types). Some informal examples of types encodable in this system are ``an
  integer'', ``a basic block taking an integer as argument'' or ``a tuple of two
  integers''. \todo{Write something similar to: The syntax
    $\forall[\Delta] \Gamma$ should be interpreted as the type of a basic block
    with type parameters $\Delta$ taking registers with types $\Gamma$. This
    could intuitively be interpreted as a function taking $\Gamma$ as an
    argument and never returning.}
\item \emph{Type assignments} are the assumptions used in types. They are used
  for parametric polymorphism.
\item \emph{Stack types} are the type of stacks.
\item \emph{Global label assignments} are the types of global collections.
\item \emph{Heap label assignments} are the types of heap collections.
\item \emph{Register assignments} are the types of register files.
\item An \emph{instantiation} is an encoding of a substitution. This
  substitution can be applied to an expression. For instance we will write
  $\tau[\theta]$ as substitution for base types and similar for other
  construction. As an example we have
  $(\langle \alpha_1, \alpha_2 \rangle)[\mathtt{int} / \alpha_1] = \langle
  \mathtt{int}, \alpha_2 \rangle$.
\item Sometimes it is useful to run more than one instantiation. The syntactic
  category \emph{instantiations} is used for this. We will write $\tau[\Theta]$
  for running multiple substitutions.  For instance
  $(\langle \alpha_1, \alpha_2 \rangle)[\mathtt{int} / \alpha_1 :: \mathtt{uninit} /
  \alpha_2 :: \nil] = \langle \mathtt{int}, \mathtt{uninit} \rangle$.
\end{itemize}

The other differences are:

\begin{itemize}
\item The global values and heap values have had a type added to them. This is
  mostly used to allow decidable type-checking, as nothing will depend on these
  values at run-time. The $\Delta$ in the definition of global values is a
  binder which allows parametric polymorphism.
\item The \texttt{malloc} instruction have been changed to include the type of
  the allocated tuple.
\item Instantiations have been added to word values and small values. This is
  used to instantiate and weaken the parametric polymorphism of code
  pointers. To give an example, assume that $\high w$ is a small-value referring
  to some basic block with the polymorphic parameters $\Delta$. In that case
  $\Lambda\ \Delta' \cdot \high{w}[\Theta]$ refers to a basic block with
  polymorphic parameters $\Delta'$. This basic block is the result of using
  $\Theta$ to instantiate $\Delta$. Here $\Theta$ is allowed to use $\Delta'$ in
  its instantiation.
\end{itemize}

\begin{figure}
  {\footnotesize
    \begin{tabular}{lrcl}
      Variables: \\
      \textit{global pointers} & $\ell_{\mathrm{g}}$ \\
      \textit{heap pointers}   & $\ell_{\mathrm{h}}$ \\
      \textit{type variable}   & $\alpha$ \\
      \textit{stack variable}  & $\rho$ \\\\

      Common definitions: \\
      \textit{integer}            & $n$ & ::= & $0, 1, \dots$ \\
      \textit{machine integers}   & $i$ & ::= & $0, 1, \dots, 2^{\mathrm{wordsize}}-1$ \\
      \textit{registers}          & $r$ & ::= & $\mathtt{r}_1 \mid \dots \mid \mathtt{r}_{\mathrm{max}}$ \\\\

      The type system for \ATAL: \\
      \textit{base types}               & $\tau$ & ::= & $\alpha \mid \mathtt{int} \mid \mathtt{uninit} \mid \mathtt\forall[ \Delta ] \Gamma \mid \langle\tau^\phi,\dots,\tau^\phi\rangle$ \\
      \textit{initialization flags}     & $\phi$ & ::= & $\mathtt{init} \mid \mathtt{uninit}$ \\
      \textit{stack types}              & $\sigma$ & ::= & $\rho \mid \nil \mid \tau :: \sigma$ \\
      \textit{type assignments}         & $\Delta$ & ::= & $\nil \mid a :: \Delta$ \\
      \textit{type assignment value}    & $a$ & ::= & $\alpha \mid \rho$ \\
      \textit{global label assignments} & $\Psi_{\mathrm{g}}$ & ::= & $\{\ell_{\mathrm{g}} |-> \tau, \dots, \ell_{\mathrm{g}} |-> \tau\}$ \\
      \textit{heap label assignmentss}  & $\Psi_{\mathrm{h}}$ & ::= & $\{\ell_{\mathrm{h}} |-> \tau, \dots, \ell_{\mathrm{h}} |-> \tau\}$ \\
      \textit{register assignments}     & $\Gamma$ & ::= & $\{\mathtt{sp} |-> \sigma, \mathtt{r}_1 |-> \tau, \dots, \mathtt{r}_{\mathrm{max}} |-> \tau\}$ \\
      \textit{instantiation}            & $\theta$ & ::= & $\tau/\alpha \mid \sigma/\rho$ \\
      \textit{instantiations}           & $\Theta$ & ::= & $\theta :: \Theta \mid \nil$ \\\\

      The syntax for \ATAL itself: \\
      \textit{word values}              & $\high w$ & ::= & $\mathtt{int}\ i \mid \mathtt{globval}\ \ell_{\mathrm{g}} \mid \Lambda\ \Delta \cdot \high{w}[\Theta] \mid \mathtt{heapval}\ \ell_{\mathrm{h}} \mid \mathtt{uninit}$ \\
      \textit{small values}             & $\high v$ & ::= & $\mathtt{int}\ i \mid \mathtt{globval}\ \ell_{\mathrm{g}} \mid \Lambda\ \Delta \cdot \high{v}[\Theta] \mid \mathtt{reg}\ r$ \\
      \textit{global values}            & $\high g$ & ::= & $\mathtt{code}[ \Delta ] \Gamma \cdot \high I$ \\
      \textit{heap values}              & $\high h$ & ::= & $\mathtt{tuple}\ \langle \tau, \dots, \tau \rangle\ \langle \high w, \dots, \high w \rangle$ \\
      \textit{stacks}                   & $\high S$ & ::= & $\nil \mid \high w :: \high S$ \\
      \textit{instructions} & $\high\iota$ & ::= & $\mathtt{add}\ r, r, \high v \mid \mathtt{sub}\ r, r, \high v \mid$ \\
                               &&& $\mathtt{salloc}\ n \mid \mathtt{sfree}\ n \mid$ \\
                               &&& $\mathtt{ld}\ r, \mathtt{sp}(n) \mid \mathtt{ld}\ r, r(n) \mid$ \\
                               &&& $\mathtt{st}\ \mathtt{sp}(n), r \mid \mathtt{st}\ r(n), r \mid$ \\
                               &&& $\mathtt{malloc}\ r,\ \langle \tau, \dots, \tau \rangle \mid $ \\
                               &&& $\mathtt{mov}\ r, \high v \mid \mathtt{beq}\ r, \high v$ \\
      \textit{instruction sequences} & $\high I$ & ::= & $\high\iota ; \high I \mid \mathtt{jmp}\ \high v \mid \mathtt{halt}$ \\\\

      \textit{global collections}       & $\high G$ & ::= & $\{\ell_{\mathrm{g}} |-> \high{g}, \dots, \ell_{\mathrm{g}} |-> \high{g}\}$ \\
      \textit{heap collections}         & $\high H$ & ::= & $\{\ell_{\mathrm{h}} |-> \high{h}, \dots, \ell_{\mathrm{h}} |-> \high{h}\}$ \\
      \textit{register files}           & $\high R$ & ::= & $\{\mathtt{sp} |-> \high{S}, \mathtt{r}_1 |-> \high{w}, \dots, \mathtt{r}_{\mathrm{max}} |-> \high{w}\}$ \\
      \textit{program states} & $\high P$ & ::= & $(\high G, \high H, \high R, \high I)$ \\
    \end{tabular}
  }
  \caption{The syntax for \ATAL}
  \label{fig:syntax}
\end{figure}

\begin{figure}
\begin{align*}
&\mathtt{code}[ \alpha_1, \rho_1 ]\\
&\ \ \ \{\mathtt{sp} |-> \rho_1, \mathtt{r}_1 |-> \mathtt{int}, \mathtt{r}_2 |-> \forall[\alpha_2] \{\mathtt{sp} |-> \rho_1, \dots\}, \mathtt{r}_3 |-> \forall[\alpha_3] \{\mathtt{sp} |-> \rho_1, \dots\}, \mathtt{r}_4 |-> \alpha_1\} \\
&\ \ \ \mathtt{beq}\ \mathtt{r}_1, (\Lambda\ \nil \cdot \mathtt{r}_2 [...]) ; \\
&\ \ \ \mathtt{jmp}\ (\Lambda\ \nil \cdot \mathtt{r}_2 [...])
\end{align*}
\caption{Example of how to use parametric polymorphism. Some of the details have
  been left out for clarity. For the full details, see the definition
  \texttt{condjmp} in \texttt{Example.agda}.}
\label{fig:parexample}
\end{figure}
\todo{Reread the polymorphism example and text \emph{carefully}.}

\subsection{Notes on the Agda Implementation}

Our Agda-version of this syntax is implemented in the
\texttt{Judgments/HighSyntax.agda}, which is very close to the above
presentation. Additionally the file \texttt{Judgments/Substitution.agda}
contains definitions of substitution and weakening.

Our handling of $\ell_{\mathrm{g}}, \ell_{\mathrm{h}}$, registers and
dictionaries is completely equivalent to what we did in \ATALe. The newly
introduced variables $\alpha$ and $\rho$ are used for name-binding instead of
looking up values in dictionaries. We are still using natural numbers though, in
this case as a way to implement De Bruijn indices.

The fact that we are using De Bruijn indices for variables in different
syntactic categories turns out to be slightly problematic. In our paper notation
a substitution is always well-defined, however in our Agda-code we might use a
particular De Bruijn index wrong. This implies that substitution is not a total
function in our Agda code -- a substitution might fail if referring to a $\rho$
where an $\alpha$ is needed.\footnote{I think this problem might have been
  avoided, but using the De Bruijn indices slightly different. I have written a
  bit about this idea in the Future Work section.}

For this reason, we have chosen to implement substitution as a relation, which
we will prove to be a partial, computable function. We also need to implement
weakening explicitly, which we do using a regular (total) function. These are
the type declarations from the file \texttt{Judgments/Substitution.agda}, where
$A$ is one of the datatypes for which substitution is valid:

\begin{code}
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{weaken} \AgdaSymbol{:} \AgdaDatatype{ℕ} \AgdaSymbol{→} \AgdaDatatype{ℕ} \AgdaSymbol{→} \AgdaBound{A} \AgdaSymbol{→} \AgdaBound{A}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{\_⟦\_/\_⟧≡\_} \AgdaSymbol{:} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Instantiation} \AgdaSymbol{→} \AgdaDatatype{ℕ} \AgdaSymbol{→} \AgdaBound{A} \AgdaSymbol{→} \AgdaPrimitiveType{Set}\<%
\end{code}

\subsection{Lemmas}

The file \texttt{Lemmas/Equality.agda} contains proofs of decidable equality
using the same method as for \ATALe. Additionally the file
\texttt{Lemmas/Substitution.agda} holds some lemmas about substitution such as:

\begin{lemma}
  \label{lemma:computsubst}
  Substitution is a partial, computable function. More specifically:
  \begin{itemize}
  \item If $\tau[\theta]$ evaluates to both $\tau_1$ and $\tau_2$, then
    $\tau_1 = \tau_2$.
  \item It is decidable to check if $\tau[\theta]$ is well-defined.
  \end{itemize}

  Similar statements hold for the other syntactic categories.
\end{lemma}

These proofs are in principle trivial, and proved by simple structural induction
over the arguments for the substitutions. In practice this involved a few tricky
cases and a lot of boilerplate code.

The file additionally contains lemmas about the commutativity of substitutions
and weakenings. A very informal version of this lemma is as follows:

\begin{lemma}
  Assume we have $\tau_1[\theta] = \tau_2$. This equation still holds if we
  weaken $\tau_1, \tau_2$ and $\theta$. A similar statement holds if we
  instead of weakening run another substitution $\theta'$ on each part.

  Similar statements hold for the other syntactic categories.
\end{lemma}

This statement is hard to state precisely, as it depends heavily on the details
of our De Bruijn indices, which we have left out in this paper. A more precise
definition of the lemma along with the proofs are available in the source
code\footnote{Specifically see the functions \texttt{weaken-subst} and
  \texttt{subst-subst} in \texttt{Lemmas/Substitution.agda}}.

The proofs themselves are for the most part done using structural induction. The
only non-trivial cases are those dealing directly with De Bruijn notation -- but
some of those require several sub-lemmas.

\section{Differences between STAL and \ATAL}
\label{sec:rel-stal}

There are a number of differences between STAL and \ATAL. We will here list,
what we believe to be a comprehensive list.

\begin{itemize}
\item Compound stacks and existential types are not present in \ATAL. They could
  possibly be added later.
\item The concepts of uninitalized values and nonsense values were separate in
  STAL and have been unified in \ATAL.
\item \ATAL have fewer arithmetic instructions and fewer conditional branch
  instructions (though adding the remaining ones would be trivial).
\item STAL had an unbounded number of registers, while \ATAL has a fixed number
  of registers. The exact number does not matter for any of our proofs, though
  we require the number to be fixed.
\item In STAL, heaps contained both code and data. This was split out in the
  definition of \ATAL. This is by itself quite a small change, but it has
  influence on the following change.
\item Small values no longer depend on word values, and instead re-state some of
  the clauses of word values. A side-effect of this is that small values cannot
  refer to values on the heap, which makes our typing judgments simpler.
\item Tuples have been tagged with their types. STAL did not have a fully
  decidable type system, as it could not type-check program states with tuples
  on the heap. As we will see in \cref{sec:decidability}, this change is what
  allows us to type-check any program state for \ATAL\footnote{It seems likely
    that the type system would still be decidable even if this change was not
    implemented, though it would be much more involved to check the heap.}. If
  one strongly desired to remain compatible with STAL, we could simply disallow
  tuples before running the type-checker with no negative effect.
\item Our handling of parametric polymorphism have been generalized. Instead of
  simply allowing instantiating the type parameters, we also allow generalizing
  them using a unified syntactic construct.
\item In \cref{chap:types} we will introduce our subtyping relation. Here we
  will introduce the last change of importance. In STAL, there were two sources
  of subtyping: A tuple could be cast to a less initialized one and a function
  could be cast to one that had more requirements for its registers. \ATAL only
  has the first source of subtyping. It is the authors belief that any use if
  this feature could alternatively have been achieved using parametric
  polymorphism, though as seen in \cref{fig:parexample} the result is not
  necessarily pretty.
\item Also in \cref{chap:types}, we will see that our typing judgments have in
  general been implemented slightly differently. We believe that our
  implementation is equivalent while slightly simpler. In particular it has
  avoided the judgment $\Delta |- \tau = \tau$. We believe that we have achieved
  the same goal simplyer using the syntactic equality from Agda's standard
  library.
\end{itemize}

To sum up: We believe that \ATAL is fundamentally compatible with STAL though
somewhat simpler, with the only significant missing features being compound
stacks (and hence exceptions) along with existential types. Additionally many
examples of existential types usage in STAL seems to be rewritable using
parametric polymorphism instead.\footnote{The author have not yet seen an
  example that could not be rewritten. He conjectures that all cases can in fact
  be rewritten, though he has not spent much time pondering it in depth.}

\section{Semantics for \ATAL}

This brings us to the semantics for \ATAL. There are a few different judgments
used:

\begin{tabular}{|c|p{7.5 cm}|}
  \hline
  Judgment & \multicolumn{1}{|c|}{Meaning} \\\hline
  $\evalregs{\high R}{\high v}{\high w}$ & Here $\high v$ is a small value, that is used an argument to an instruction. This judgment states that we can evaluate $v$ to $\high w$ by looking up registers in the register file $\high R$. \\\hline
  $\evalcode{\high G}{\high w}{\high I}$ & Here $\high w$ is a word value that we intend to jump to. This judgment states that we can evaluate $\high w$ to the basic block $\high I$ by looking up basic blocks in $\high G$ and possibly instantiating some of the type variables. \\\hline
  $\execis{\high G}{\high H, \high R, \high I}{\high H', \high R', \high I'}$ & This is our main small-step relation. It is a judgment that asserts that if a program is in state $(\high G, \high H, \high R, \high I)$, then it can transition to $(\high G, \high H', \high R', \high I')$. Note that $G$ is immutable. \\\hline
  $\steps{\high P}{\high P'}$ & This states that the program state $\high P$ can small-step to $\high P'$. It has only a single rule which uses the judgment above. \\\hline
  $\stepsn{\high P}{n}{\high P'}$ & This states that the program state $\high P$ can small-step to $\high P'$ in $n$ steps. \\\hline
\end{tabular} \\

Let us start with the last two judgments as they are the simplest: \\

\fbox{$\steps{\high P}{\high P'}$}
\begin{mathpar}
  \infer{
    \execis{\high G}{(\high H, \high R, \high I)}{(\high H', \high R', \high I')}
  }{
    \steps{(\high G, \high H, \high R, \high I)}{(\high G, \high H', \high R', \high I')}
  }
\end{mathpar}

\fbox{$\stepsn{\high P}{n}{\high P'}$}
\begin{mathpar}
  \infer{
  }{
    \stepsn{\high P}{0}{\high P}
  } \and
  \infer{
    \steps{\high P}{}{\high P'} \and
    \stepsn{\high P'}{n}{\high P''}
  }{
    \stepsn{\high P}{1+n}{\high P''}
  }
\end{mathpar}

The definition for $\evalregs{\high R}{\high v}{\high w}$ is also pretty simple
-- it simply replaces \texttt{reg}-values by looking up the register in the
register file: \\

\fbox{$\evalregs{\high R}{\high v}{\high w}$}
\begin{mathpar}
  \infer{
  }{
    \evalregs{\high R}{\mathtt{reg}\ r}{\high R[r]}
  } \and
  \infer{
  }{
    \evalregs{\high R}{\mathtt{globval}\ \ell_{\mathrm{g}}}{\mathtt{globval}\ \ell_{\mathrm{g}}}
  } \and
  \infer{
  }{
    \evalregs{\high R}{\mathtt{int}\ i}{\mathtt{int}\ i}
  } \and
  \infer{
    \evalregs{\high R}{\high v}{\high w}
  }{
    \evalregs{\high R}{\Lambda\ \Delta \cdot \high{v}[\Theta]}{\Lambda\ \Delta \cdot \high{w}[\Theta]}
  }
\end{mathpar}

\todo{More text about small-step judgments}

\fbox{$\evalcode{\high G}{\high w}{I}$}
\begin{mathpar}
\infer{
  \high G[\ell_{\mathrm{g}}] = \mathtt{code}[ \Delta ] \Gamma \cdot \high I
}{
  \evalcode{\high G}{\mathtt{globval}\ \ell_{\mathrm{g}}}{\high I}
} \and
\infer{
  \evalcode{\high G}{w}{\high I} \and
  \high I' = \high I[\Theta]
}{
  \evalcode{\high G}{\Lambda\ \Delta \cdot \high w[\Theta]}{\high I'}
}
\end{mathpar}

\todo{Even more text about small-step judgments}

\fbox{$\execis{\high G}{\high H, \high R, \high I}{\high H', \high R', \high I'}$}
\begin{mathpar}
\infer{
  \high R[r_b] = \mathtt{int}\ i_1 \and
  \evalregs{\high R}{\high v}{\mathtt{int}\ i_2}
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{add}\ r_a, r_b, \high v) ; \high I}
    {\high H, \high R[r_a \mapsto \mathtt{int}\ (i_1 + i_2)], \high I}
} \and
\infer{
  \high R[r_b] = \mathtt{int}\ i_1 \and
  \evalregs{\high R}{\high v}{\mathtt{int}\ i_2}
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{sub}\ r_a, r_b, \high v) ; \high I}
    {\high H, \high R[r_1 \mapsto \mathtt{int}\ (i_1 - i_2)], \high I}
} \and
\infer{
  \high S = \overbrace{\mathtt{uninit} :: \dots :: \mathtt{uninit}}^n :: \high R[\mathtt{sp}]
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{salloc}\ n) ; \high I}
    {\high H, \high R[\mathtt{sp} |-> \high S], \high I}
} \and
\infer{
  \high R[\mathtt{sp}] = \overbrace{\high w_1 :: \dots :: \high w_n}^n :: \high S
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{sfree}\ n) ; \high I}
    {\high H, \high R[\mathtt{sp} |-> \high S], \high I}
} \and
\infer{
  \high R[\mathtt{sp}][n] = \high w
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{ld}\ r, \mathtt{sp}(n)) ; \high I}
    {\high H, \high R[r |-> \high w], \high I}
} \and
\infer{
  \high R[r_b] = \mathtt{heapval}\ \ell_{\mathrm{h}} \and
  \high H[\ell_{\mathrm{h}}] = \mathtt{tuple}\ \langle \tau_1, \dots \rangle\ \langle \high w_1, \dots, \high w_n, \dots \rangle
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{ld}\ r_a, r_b(n)) ; \high I}
    {\high H, \high R[r_a |-> \high w_n], \high I}
} \and
\infer{
  R[r] = \high w \and
  R[\mathtt{sp}] = \high S
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{st}\ \mathtt{sp}(n), r) ; \high I}
    {\high H, \high R[\mathtt{sp} |-> \high S[n |-> \high w]], \high I}
} \and
\infer{
  \high R[r_a] = \mathtt{heapval}\ \ell_{\mathrm{h}} \and
  \high H[\ell_{\mathrm{h}}] = \mathtt{tuple}\ \langle \tau_1, \dots \rangle\ \langle \high w_1, \dots \high w_n, \dots \rangle \and
  \high R[r_b] = \high w \and
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{st}\ r_a(n), r_b) ; \high I}
    {\high H[\ell_{\mathrm{h}} |-> \mathtt{tuple}\ \langle \tau_1, \dots, \rangle\ \langle \high w_1, \dots, \high w, \dots \rangle], \high R, \high I}
} \and
\infer{
  \ell_{\mathrm{h}} \notin \mathbf{dom}(\high H) \and
  \high h = \mathtt{tuple}\ \langle \tau_1, \dots, \tau_n \rangle\ \overbrace{\langle \mathtt{uninit}, \dots, \mathtt{uninit} \rangle}^n
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{malloc}\ r, \langle \tau_1, \dots, \tau_n \rangle) ; \high I}
    {\high H \cup \{\ell_{\mathrm{h}} |-> \high h\}, R[r |-> \mathtt{heapval}\ \ell_{\mathrm{h}}], \high I}
} \and
\infer{
  \evalregs{\high R}{\high v}{\high w}
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{mov}\ r, \high v) ; \high I}
    {\high H, \high R[r |-> \high w], \high I}
} \and
\infer{
  \high R[r] = \mathtt{int}\ 0 \and
  \evalregs{\high R}{\high v}{\high w} \and
  \evalcode{\high G}{\high w}{I'}
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{beq}\ r, \high v) ; \high I}
    {\high H, \high R, \high I'}
} \and
\infer{
  \high R[r] = \mathtt{int}\ i \and
  i \neq 0
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{beq}\ r, \high v) ; \high I}
    {\high H, \high R, \high I}
} \and
\infer{
  \evalregs{\high R}{\high v}{\high w} \and
  \evalcode{\high G}{\high w}{I}
}{
  \execis{\high G}
    {\high H, \high R, \mathtt{jmp}\ \high v}
    {\high H, \high R, \high I}
}
\end{mathpar}

\subsection{Notes on the Agda Implementation}

The file \texttt{Judgments/HighSemantics.agda} is very close in form to this
presentation. We have deviated slightly from this form, as the Agda-version uses
functions for some syntax where the thesis uses premises and vice versa.

\subsection{Lemmas}

It turns out that our small-semantics is deterministic, which implies that it is
a partial function, so the following lemma is proved in the file
\texttt{Lemmas/HighSemantics.agda}.

\begin{lemma}
  \label{lemma:computhigh}
  Our small-step relation for \ATAL is a partial, computable function. Or more
  precisely:

  \begin{itemize}
  \item If $\high P, \high P', \high P''$ are a program states and we have both
    $\steps{\high P}{\high P'}$ and $\steps{\high P}{\high P''}$, then
    $\high{P'} = \high{P''}$.
  \item It is decidable whether $\high P$ can small-step to some $\high P'$.
  \end{itemize}

  Similar lemmas exists for the other semantic judgments.
\end{lemma}

\section{Semantics for \ATALe}

The semantics for \ATALe er mostly the same as for \ATAL\ -- it has the same 5
core judgments as. The difference are:

\begin{itemize}
\item $\evalregs{\simple R}{\simple v}{\simple w}$ has one case less than
  $\evalregs{\high R}{\high v}{\high w}$ because \ATALe does not have the
  instantiation syntax.
\item For the same reason there is one fewer case for
  $\evalcode{\simple G}{\simple w}{\simple I}$. Note that this makes the
  judgment mostly trivial.
\item
  $\execis{\simple G}{\simple H, \simple R, \simple I}{\simple H', \simple R',
    \simple I'}$ has changed slightly. The cases for $\mathtt{ld}\ r_a, r_b(n)$
  and $\mathtt{st}\ r_a(n), r_b$ have been simplified in the obvious way as
  tuples no longer carry type information. The case for $\mathtt{malloc}$ is the
  only one that has a non-trivial change:
\end{itemize}

\begin{mathpar}
\infer{
  \ell_{\mathrm{h}} \notin \mathbf{dom}(\simple H) \and
  \simple h = \mathtt{tuple}\ \overbrace{\langle \mathtt{uninit}, \dots, \mathtt{uninit} \rangle}^n
}{
  \execis{\simple G}
    {\simple H, \simple R, (\mathtt{malloc}\ r, n) ; \simple I}
    {\simple H \cup \{\ell_{\mathrm{h}} |-> \simple h\}, R[r |-> \mathtt{heapval}\ \ell_{\mathrm{h}}], \simple I}
} \and
\end{mathpar}

The full semantics for \ATALe have been included in the in
\cref{sec:full-atale}.

\subsection{Notes on the Agda Implementation}

The file \texttt{Judgments/SimpleSemantics.agda} is again very close in form to
this presentation. We have made the same deviations as we did for \ATAL.

\subsection{Lemmas}

It should be no surprise that this small-step semantics is deterministic, given
that it is mostly the same as for \ATAL. We prove the following lemma in
\texttt{Lemmas/SimpleSemantics.agda}:

\begin{lemma}
  \label{lemma:computsimple}
  Our small-step relation for \ATALe is a partial, computable function. Or more
  precisely:

  \begin{itemize}
  \item If $\simple P, \simple{P'}, \simple{P''}$ are a program states and we
    have both $\steps{\simple P}{\simple{P'}}$ and
    $\steps{\simple P}{\simple{P''}}$, then
    $\simple{P'} = \simple{P''}$.
  \item It is decidable whether $\simple P$ can small-step to some
    $\simple{P'}$.
  \end{itemize}

  Similar lemmas exists for the other semantic judgments.
\end{lemma}
