\chapter{Lessons learned from using Agda}
\label{chap:hindsight}

The purpose of this chapter is to give document some of my experiences with
learning Agda and using it to implement my TAL. This was my first real project
in Agda, and as such I have made a lot of errors that could have been avoided
had I known the language better.

As such this chapter will contain some nice tips-and-tricks I have discovered
mixed with some of my (hopefully) interesting observations about learning the
language.

\section{Extending the Standard Library}

When initially learning Agda, the standard library likely to be ones biggest
guide for writing practical Agda-code. The good news is that the standard
library is generally of high quality and contain many useful functions for doing
very general-purpose things. The bad news is that 1) the libraries have often
been generalized to the point where they are completely unusable by new users
and 2) for some of the library it seems somewhat random which lemmas have been
deemed important enough to be included.

As such I was somewhat forced to implement my own standard library on top of the
Agda standard library. This was very good practice for learning Agda, however it
was also somewhat wasteful. As I continued learning the language I noticed that
considerable parts of my own library was actually present in the Agda standard
library. This unfortunately did not mean that I could simply stop using my own
implementation, as the version in the standard library was often slightly
different, harder to use or had issues related to scoping in the module system.

\section{Decidable Equality}
\label{sec:deceq}

One of the general-purpose techniques I am most proud of is my solution to
proving decidable equality. In Agda one often wants to prove decidable equality
for some type $T$. In particular one wishes to prove a lemma of the following
form:

\begin{lemma}[Decidable Equality]
  Let $v_1, v_2 \in T$. We can now derive a proof of either $v_1 \equiv v_2$ or
  $v_1 \not\equiv v_2$.
\end{lemma}

This lemma is in Agda often written as a dependent function with the signature:

$$\cdot ≟ \cdot\;\;:\;\;(v_1 : T) \to (v_2 : T) \to \mathtt{Dec}(v_1 \equiv v_2)$$

An example from Agda standard library (with slight modifications):

\begin{code}%
\>\<%
\\
\>\AgdaFunction{\_≟\_} \AgdaSymbol{:} \AgdaSymbol{(}\AgdaBound{v₁} \AgdaSymbol{:} \AgdaDatatype{Bool}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{v₂} \AgdaSymbol{:} \AgdaDatatype{Bool}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{Dec} \AgdaSymbol{(}\AgdaBound{v₁} \AgdaDatatype{≡} \AgdaBound{v₂}\AgdaSymbol{)}\<%
\\
\>\AgdaInductiveConstructor{true} \<[6]%
\>[6]\AgdaFunction{≟} \AgdaInductiveConstructor{true} \<[14]%
\>[14]\AgdaSymbol{=} \AgdaInductiveConstructor{yes} \AgdaInductiveConstructor{refl}\<%
\\
\>\AgdaInductiveConstructor{false} \AgdaFunction{≟} \AgdaInductiveConstructor{false} \AgdaSymbol{=} \AgdaInductiveConstructor{yes} \AgdaInductiveConstructor{refl}\<%
\\
\>\AgdaInductiveConstructor{true} \<[6]%
\>[6]\AgdaFunction{≟} \AgdaInductiveConstructor{false} \AgdaSymbol{=} \AgdaInductiveConstructor{no} \AgdaSymbol{λ()}\<%
\\
\>\AgdaInductiveConstructor{false} \AgdaFunction{≟} \AgdaInductiveConstructor{true} \<[14]%
\>[14]\AgdaSymbol{=} \AgdaInductiveConstructor{no} \AgdaSymbol{λ()}\<%
\end{code}

\paragraph{}
While these types of lemmas are in principle trivial to generate for most
datatypes, there is a problem: required number of lines is \emph{quadratic} in
the number of constructors for the datatype. The reason for this quadratic
explosion is the need to generate proofs for $v_1 \neq v_2$.

I found a solution to the problem in a blog-post\cite{deceq}, though I
generalized the solution slightly. The idea is a follows:

\begin{itemize}
\item Construct an injective function $f$ from the original type $T$ to another
  type $T'$.
\item Prove decidable equality for $T'$.
\item Use this to decide $f(v_1) \equiv f(v_2)$.
\item We know that $f(v_1) \not\equiv f(v_2)$ implies $v_1 \not\equiv v_2$,
  since $f$ is a function.
\item We also know that $f(v_1) \equiv f(v_2)$ implies $v_1 \equiv v_2$, since
  $f$ is injective.
\item If we combine these, we get decidable equality for $T$.
\end{itemize}

By choosing $T'$ to be the same for every $T$, we can reuse a lot code. In
practice my code does the following:

\begin{itemize}
\item Define a type \texttt{Tree}, which is the set of rooted, ordered tree
  having a number attached to each node. This datatype was chosen since this
  makes it easy to construct the injective functions.
\item Prove decidable equality for \texttt{Tree}.
\item Prove that given $T$ and an injective functions $f : T \to \mathtt{Tree}$,
  we have decidable equality for $T$.
\item Prove that given $T$ and a surjective function $g : \mathtt{Tree} \to T$,
  we can construct an injective function $f : T \to \mathtt{Tree}$, and thus
  this also implies decidable equality on $T$.
\end{itemize}

This last step is a slight further optimization, as it turns out to take fewer
lines of code in Agda to specify a $g$ and prove it surjective, than to specify
a function $f$ and prove it injective.

For each additional type $T$ for which you want to prove decidable equality, you
now only need to:

\begin{itemize}
\item Create a function $g : \mathtt{Tree} \to T$.
\item Prove that $g$ is surjective.
\end{itemize}

For most datatypes, will only require $2k+3$ lines (or slightly more if we wrap
long lines), where $k$ is the number of number of constructors in the definition
of $T$.

\todo{Insert reference to appendix, where usage of this can be seen.}

\section{Predicates on Lists}
\todo{write me}
All, AllZip, lookup, update and variants.

\section{Using records to emulate type-classes}
\todo{write me}

\section{Experiments with the MixFix parser}
\todo{write me}

\section{Something about decidable propositions}
Include something about \texttt{dec-force}.
\todo{write me}

\section{Extensions to Equality Reasoning}
Not that smart or interesting. One would rather try to avoid equality reasoning,
but if that is not possible, one might as well have as strong a hacksaw as
possible.

\todo{Write about equality reasoning}

\section{Substitutions}
I think I should be able to same something semi-smart about this.

\todo{Write about substitutions}
