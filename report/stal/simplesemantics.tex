\subsection{Semantics}

We are now able to implement the semantics for our language: \\

\fbox{$\evalbig{R}{v}{w}$}
\begin{mathpar}
\infer{ }{
  \evalbig{R}{\mathtt{globval}\ \ell_g}{\mathtt{globval}\ \ell_g}
} \and
\infer{
  (r \mapsto w) \in R
}{
  \evalbig{R}{\mathtt{reg}\ r}{w}
} \and
\infer{ }{
  \evalbig{R}{\mathtt{int}\ i}{\mathtt{int}\ i}
} \and
\infer{ }{
  \evalbig{R}{\mathtt{ns}}{\mathtt{ns}}
} \and
\infer{ }{
  \evalbig{R}{\mathtt{uninit}}{\mathtt{uninit}}
}
\end{mathpar}

\fbox{$\execinstruction{G}{H, R, I}{H', R', I'}$}
\begin{mathpar}
\infer{
  \evalbig{R}{v}{\mathtt{int}\ i_1} \and
  (\mathtt{r}_s \mapsto \mathtt{int}\ i_2) \in R
}{
  \execinstruction{G}
    {H, R, (\mathtt{add}\ r_d, r_s, v) ; I}
    {H, R\{r_d \mapsto \mathtt{int}\ (i_1 + i_2)\}, I}
} \and
\infer{
  \evalbig{R}{v}{\mathtt{int}\ i_1} \and
  (r_s \mapsto \mathtt{int}\ i_2) \in R
}{
  \execinstruction{G}
    {H, R, (\mathtt{sub}\ r_d, r_s, v) ; I}
    {H, R\{r_d |-> \mathtt{int}\ (i_1 - i_2)\}, I}
} \and
\infer{
  (\mathtt{sp} |-> S) \in R \and
  S' = \overbrace{\mathtt{ns} :: \dots :: \mathtt{ns}}^n :: S
}{
  \execinstruction{G}
    {H, R, \mathtt{salloc}\ n ; I}
    {H, R\{\mathtt{sp} |-> S'\}, I}
} \and
\infer{
  (\mathtt{sp} |-> S) \in R \and
  S = \overbrace{w_1 :: \dots :: w_n}^n :: S'
}{
  \execinstruction{G}
    {H, R, \mathtt{sfree}\ n ; I}
    {H, R\{\mathtt{sp} |-> S'\}, I}
} \and
\infer{
  (\mathtt{sp} |-> S) \in R \and
  S ! n => w
}{
  \execinstruction{G}
    {H, R, (\mathtt{ld}\ r_d, \mathtt{sp}(n)) ; I}
    {H, R\{r_d |-> w\}, I}
} \and
\infer{
  (r_s |-> \mathtt{heapval}\ \ell_h) \in R \and
  (\ell_h |-> h) \in H \and
  h ! n => w
}{
  \execinstruction{G}
    {H, R, (\mathtt{ld}\ r_d, r_s(n)) ; I}
    {H, R\{r_d |-> w\}, I}
} \and
\infer{
  (r_s |-> w) \in R \and
  (\mathtt{sp} |-> S) \in R \and
  S[n] <- w => S'
}{
  \execinstruction{G}
    {H, R, (\mathtt{st}\ \mathtt{sp}(n), r_s) ; I}
    {H, R\{\mathtt{sp} |-> S'\}, I}
} \and
\infer{
  (r_s |-> w) \in R \and
  (r_d |-> \mathtt{heapval}\ \ell_h) \in R \and
  (\ell_h |-> h) \in H \and
  h[n] <- w => h'
}{
  \execinstruction{G}
    {H, R, (\mathtt{st}\ r_d(n), r_s) ; I}
    {H\{\ell_h |-> h'\}, R, I}
} \and
\infer{
  \ell_h \not\in \mathbf{Keys}(H) \and
  h = \overbrace{\langle \mathtt{uninit}, \dots, \mathtt{uninit} \rangle}^n
}{
  \execinstruction{G}
    {H, R, (\mathtt{malloc}\ r_d, n) ; I}
    {H \cup \{\ell_h |-> h\}, R\{r_d |-> \mathtt{heapval}\ \ell_h\}, I}
} \and
\infer{
  \evalbig{R}{v}{w}
}{
  \execinstruction{G}
    {H, R, (\mathtt{mov}\ r_d, v) ; I}
    {H, R\{r_d |-> w\}, I}
} \and
\infer{
  (r |-> \mathtt{int}\ 0) \in R \and
  \evalbig{R}{v}{\mathtt{globval}\ \ell_g} \and
  G ! \ell_g => \mathtt{code}\ I'
}{
  \execinstruction{G}
    {H, R, (\mathtt{beq}\ r, v) ; I}
    {H, R, I'}
} \and
\infer{
  (r |-> \mathtt{int}\ i) \in R \and
  i \neq 0
}{
  \execinstruction{G}
    {H, R, (\mathtt{beq}\ r, v) ; I}
    {H, R, I}
} \and
\infer{
  \evalbig{R}{v}{\mathtt{globval}\ \ell_g} \and
  G ! \ell_g => \mathtt{code}\ I'
}{
  \execinstruction{G}
    {H, R, \mathtt{jmp}\ v}
    {H, R, I'}
}
\end{mathpar}

\fbox{$(G, H, R, I) -> (G', H', R', I')$}
\begin{mathpar}
\infer{
  \execinstruction{G}{H, R, I}{H', R', I'}
}{
  (G, H, R, I) -> (G, H', R', I')
}
\end{mathpar}

\begin{lemma}[Determinism]
  \label{thm:determinism-simple}
  Assume $P, P_1, P_2$ are programs in the simplified language. Assume
  $P -> P_1$ and $P -> P_2$. We can conclude that $P_1 = P_2$.
\end{lemma}
\begin{proof}
  By induction over the structure of $P -> P_1$.
\end{proof}
