\section{Base language}

In the following $r_{max}$ and $w$ ares a global constants, representing
respectively the number of registers on the machine and the number of bits in a
machine-word. While it is a constant, its concrete value is never used and it
can thus vary between implementation.
\\

\subsection{Grammar}

\begin{tabular}{lrcl}
Variables: \\
\textit{global pointers}    & $\ell_g$ \\
\textit{heap pointers}      & $\ell_h$ \\
\\
\textit{integer}            & $n$ & ::= & $0, 1, \dots$ \\
\textit{machine integers}   & $i$ & ::= & $0, 1, \dots, 2^{w}-1$ \\
\textit{registers}          & $r$ & ::= & $\mathtt{r}_1 \mid \dots \mid \mathtt{r}_{r_{max}}$ \\
\textit{word values}        & $w$ & ::= & $\mathtt{globval}\ \ell_g \mid \mathtt{heapval}\ \ell_h \mid \mathtt{int}\ i \mid \mathtt{ns} \mid \mathtt{uninit}$ \\
\textit{small values}       & $v$ & ::= & $\mathtt{globval}\ \ell_g \mid \mathtt{reg}\ r \mid \mathtt{int}\ i \mid \mathtt{ns} \mid \mathtt{uninit}$ \\
\textit{global values}      & $g$ & ::= & $\mathtt{code}\ I$ \\
\textit{global collections} & $G$ & ::= & $\{\ell_g |-> g, \dots, \ell_g |-> g\}$ \\
\textit{heap values}        & $h$ & ::= & $\langle w, \dots, w \rangle$ \\
\textit{heap collections}   & $H$ & ::= & $\{\ell_h |-> h, \dots, \ell_h |-> h\}$ \\
\textit{stacks}             & $S$ & ::= & $\mathtt{nil} \mid w :: S$ \\
\textit{register files}     & $R$ & ::= & $\{\mathtt{sp} |-> S, \mathtt{r}_1 |-> w_1, \dots, \mathtt{r}_{r_{max}} |-> w_{r_{max}}\}$ \\
\\
\textit{instructions} & $\iota$ & ::= & $\mathtt{add}\ r_d, r_s, v \mid \mathtt{sub}\ r_d, r_s, v \mid$ \\
        &&& $\mathtt{salloc}\ n \mid \mathtt{sfree}\ n \mid$ \\
        &&& $\mathtt{ld}\ r_d, \mathtt{sp}(n) \mid \mathtt{st}\ \mathtt{sp}(n), r_s \mid$\\
        &&& $\mathtt{ld}\ r_d, r_s(n) \mid \mathtt{st}\ r_d(n), r_s \mid$\\
        &&& $\mathtt{malloc}\ r_d,\ n \mid $ \\
        &&& $\mathtt{mov}\ r_d, r_s \mid \mathtt{beq}\ r, v$ \\
\textit{instruction sequences} & $I$ & ::= & $\iota ; I \mid \mathtt{jmp}\ v$ \\
\textit{programs} & $P$ & ::= & $(G, H, R, I)$ \\
\end{tabular}

\paragraph{}
The mappings of the form $\{x |-> y, \dots\}$ are unordered and do not have
repeating keys. In the Agda-implementation, these maps are mostly implemented as
ordered lists with implicit keys, however we can ignore this fact when using
paper-notation.

We will occasionally refer to a specific heap collection as a \textbf{heap} or
perhaps \textbf{the heap} for a specific program state. Similarly a specific
global collection might be referred to as \textbf{the globals} of a program. We
will however not use the term ``global'' without qualification, to avoid
ambiguity between global collections and global values.

The fundamental assumption of this language is that the state of a program is
totally defined by a collection of immutable global values, the current state of
the heap, the current stack, the current registers and the current instruction
pointer. This is represented in our language as:

\begin{itemize}
\item The immutable global values are places in a global collection
  consisting of individual global items.
\item The mutable global values are places in a heap collection
  consisting of individual heap items.
\item The current stack is encoded as a stack consisting and placed inside a
  register file.
\item The value of the current registers are encoded in a register file together
  with the stack.
\item The instruction pointer is not encoded directly as a pointer, it is
  instead represented as the instructions to be run until the next block.
\end{itemize}

While this representation is enough for many programs, it also excludes many
programs by design. For instance it excludes mutable global variables not stored
on the heap and self-modifying code (such as just-in-time compilers).

It should be possible to expand the language to allow more programs, however
some sacrifice will always be needed, as we are not able to exclude malicious
programs from our semantics without also excluding some valid programs.

\subsection{Related judgments}

\todo[inline]{This is a few syntax definitions. While they might be introduced
  here, they should be defined more formally elsewhere.}

\subsubsection{Dictionaries}
A \textbf{dictionary} is an unordered set of the form
$\{x_1 |-> y_1, \dots, x_n |-> y_n\}$ with the restriction that $x_i \neq x_j$
whenever $i \neq j$.

Assume that $D_1$ and $D_2$ are arbitrary dictionaries of the form
$\{x_1 |-> y_1, \dots, x_n |-> y_n\}$ and
$\{x_1' |-> y_1', \dots, x_m' |-> y_m'\}$ respectively.

Define $\mathbf{Keys}(D_1)$ to be the set $\{x_1, \dots, x_n\}$. Whenever
$\mathbf{Keys}(D_1) \cap \mathbf{Keys}(D_2) = \emptyset$, then the expression
$D_1 \cup D_2$ denotes the the dictionary
$\{x_1 |-> y_1, \dots, x_n |-> y_n, x_1' |-> y_1', \dots, x_m' |-> y_m'\}$.

We define $D_1\{x |-> y\}$ whenever $x \in \mathbf{Keys}(D_1)$. This expression
is the dictionary $\{x_1 |-> y_1', \dots, x_n |-> y_n'\}$ subject to the
restriction that $y_k' = y$ whenever $x_k = x$ and $y_k' = y_k$ otherwise.

By $(x |-> y) \in D$ we mean a judgment asserting that $D$ is of the form
$\{x_1 |-> y_1, \dots, x_n |-> y_n\}$ and that there exists some $k$ such that
$x = x_k$ and $y = y_k$. This syntax is meaning for e.g. global collections and
register files.

\subsubsection{List-like objects}
A set $S$ is \textbf{list-like} iff there is a meaningful way to interpret the
elements of $S$ as ordered lists of elements drawn from a base-set $S_B$. In
other words, there should exist a injective function
$f : S \to \mathbf{List}\ S_B$, where $f$ may only depend on the superficial
syntax of the elements.

For instance heap values and stacks are list-like, as they are written
$\langle w_1, \dots, w_n \rangle$ and $w_1 :: \dots :: w_n :: \mathtt{nil}$
respectively.

For the remainder of this subsection, assume $L_1$ and $L_2$ are typical
elements of the same list-like set $S$. Further assume that
$f(L_1) = [x_1, \dots, x_n]$ and $f(L_2) = [y_1, \dots, y_m]$.

Define $\mathbf{Length}(L_1) = n$.

Define $L_1 >> L_2$ be the element $L_3 \in S$ such that
$f(L_3) = [x_1, \dots, x_n, y_1, \dots, y_m]$, if such an element exists.

By $L_1 ! k => v$ we mean a judgment asserting $x_k = v$.

By $L_1[k]<- v => L_2$ we mean a judgment asserting that $n=m$, $y_k=v$ and
$x_i = y_i$ if $i \neq k$.

\subsection{Semantics}

We are now able to implement the semantics for our language: \\

\fbox{$\evalbig{R}{v}{w}$}
\begin{mathpar}
\infer{ }{
  \evalbig{R}{\mathtt{globval}\ \ell_g}{\mathtt{globval}\ \ell_g}
} \and
\infer{
  (r \mapsto w) \in R
}{
  \evalbig{R}{\mathtt{reg}\ r}{w}
} \and
\infer{ }{
  \evalbig{R}{\mathtt{int}\ i}{\mathtt{int}\ i}
} \and
\infer{ }{
  \evalbig{R}{\mathtt{ns}}{\mathtt{ns}}
} \and
\infer{ }{
  \evalbig{R}{\mathtt{uninit}}{\mathtt{uninit}}
}
\end{mathpar}

\fbox{$\execinstruction{G}{H, R, I}{H', R', I'}$}
\begin{mathpar}
\infer{
  \evalbig{R}{v}{\mathtt{int}\ i_1} \and
  (\mathtt{r}_s \mapsto \mathtt{int}\ i_2) \in R
}{
  \execinstruction{G}
    {H, R, (\mathtt{add}\ r_d, r_s, v) ; I}
    {H, R\{r_d \mapsto \mathtt{int}\ (i_1 + i_2)\}, I}
} \and
\infer{
  \evalbig{R}{v}{\mathtt{int}\ i_1} \and
  (r_s \mapsto \mathtt{int}\ i_2) \in R
}{
  \execinstruction{G}
    {H, R, (\mathtt{sub}\ r_d, r_s, v) ; I}
    {H, R\{r_d |-> \mathtt{int}\ (i_1 - i_2)\}, I}
} \and
\infer{
  (\mathtt{sp} |-> S) \in R \and
  S' = \overbrace{\mathtt{ns} :: \dots :: \mathtt{ns}}^n :: S
}{
  \execinstruction{G}
    {H, R, \mathtt{salloc}\ n ; I}
    {H, R\{\mathtt{sp} |-> S'\}, I}
} \and
\infer{
  (\mathtt{sp} |-> S) \in R \and
  S = \overbrace{w_1 :: \dots :: w_n}^n :: S'
}{
  \execinstruction{G}
    {H, R, \mathtt{sfree}\ n ; I}
    {H, R\{\mathtt{sp} |-> S'\}, I}
} \and
\infer{
  (\mathtt{sp} |-> S) \in R \and
  S ! n => w
}{
  \execinstruction{G}
    {H, R, (\mathtt{ld}\ r_d, \mathtt{sp}(n)) ; I}
    {H, R\{r_d |-> w\}, I}
} \and
\infer{
  (r_s |-> \mathtt{heapval}\ \ell_h) \in R \and
  (\ell_h |-> h) \in H \and
  h ! n => w
}{
  \execinstruction{G}
    {H, R, (\mathtt{ld}\ r_d, r_s(n)) ; I}
    {H, R\{r_d |-> w\}, I}
} \and
\infer{
  (r_s |-> w) \in R \and
  (\mathtt{sp} |-> S) \in R \and
  S[n] <- w => S'
}{
  \execinstruction{G}
    {H, R, (\mathtt{st}\ \mathtt{sp}(n), r_s) ; I}
    {H, R\{\mathtt{sp} |-> S'\}, I}
} \and
\infer{
  (r_s |-> w) \in R \and
  (r_d |-> \mathtt{heapval}\ \ell_h) \in R \and
  (\ell_h |-> h) \in H \and
  h[n] <- w => h'
}{
  \execinstruction{G}
    {H, R, (\mathtt{st}\ r_d(n), r_s) ; I}
    {H\{\ell_h |-> h'\}, R, I}
} \and
\infer{
  \ell_h \not\in \mathbf{Keys}(H) \and
  h = \overbrace{\langle \mathtt{uninit}, \dots, \mathtt{uninit} \rangle}^n
}{
  \execinstruction{G}
    {H, R, (\mathtt{malloc}\ r_d, n) ; I}
    {H \cup \{\ell_h |-> h\}, R\{r_d |-> \mathtt{heapval}\ \ell_h\}, I}
} \and
\infer{
  \evalbig{R}{v}{w}
}{
  \execinstruction{G}
    {H, R, (\mathtt{mov}\ r_d, v) ; I}
    {H, R\{r_d |-> w\}, I}
} \and
\infer{
  (r |-> \mathtt{int}\ 0) \in R \and
  \evalbig{R}{v}{\mathtt{code}\ I'}
}{
  \execinstruction{G}
    {H, R, (\mathtt{beq}\ r, v) ; I}
    {H, R, I'}
} \and
\infer{
  (r |-> \mathtt{int}\ i) \in R \and
  i \neq 0
}{
  \execinstruction{G}
    {H, R, (\mathtt{beq}\ r, v) ; I}
    {H, R, I}
} \and
\infer{
  \evalbig{R}{v}{\mathtt{code}\ I'}
}{
  \execinstruction{G}
    {H, R, \mathtt{jmp}\ v}
    {H, R, I'}
}
\end{mathpar}
