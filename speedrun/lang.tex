\chapter{\ATAL and \ATALe}
\label{chap:lang}

As stated \cref{sec:goal}, we want to design a secure sandbox, and to do so we
will need to design a Typed Assembly Language and prove soundness for it. In
this chapter we will introduce the two languages in which we will build this
sandbox. We will do this by:

\begin{itemize}
\item Defining \ATAL and \ATALe in terms of their program states.
\item The set of possible program states are defined in terms a Context-Free
  Grammar in our Agda formalization. In our paper definition, we have chosen to
  use some syntax that is not Context-Free for increased readability. As we
  shall see, this is not a problem as there is a trivial correspondence between
  the two presentations.
\item We will present a small-step semantics for the two languages and prove
  that they are related by the erasure property.
\end{itemize}

The full implications of and reasoning behind having two languages related by
erasure will be discussed later. \Cref{sec:erasure} will discuss some of the
issues along with the proof, while the full reasoning will not be apparent until
\Cref{chap:safesound}. For now let us just state these two unbacked postulates
over the alternative of using a single language:

\begin{itemize}
\item By having two languages we are mostly able to separate our type system
  from our model simplification. This is advantageous for instance when
  reasoning about the sandbox implementation.
\item This separation also allows one to experiment with different type systems:
  As long as the type system is sound, decidable and has the erasure property,
  then it should be able to use the same sandbox infrastructure.
\end{itemize}

Before formally defining the languages, we will give an informal understanding
of our model by comparing it to a the model of real-world CPUs.

\section{Architecture and Evaluation Model}

Most real-world CPUs use a variant of a von Neumann architecture. In its
simplest form, you only need memory and registers each holding some number of
machine words along with a procedure to fetch an instruction from memory, decode
and execute it. This executing (optionally) changes memory and register, after
which the process is repeated. We will refer to this model as the real-world
model; even though many modern CPU-architectures are more complicated than this,
the difference are for the most part not relevant to this discussion.

In the real-world model there are only two conceptual abstractions: Machine
words are fixed-width integers and instructions are just decoded machine
words. This simplicity makes it easier to implement and analyze CPU designs,
however it makes hard to analyze programs for the platform.

To support effective program analysis, both \ATAL and \ATALe deviates from this
model in a number of ways. As \ATALe deviates the least, we will start by
introducing it.

\subsection{Difference between \ATALe and the real-world model}

In the real-world model machine words are simply fixed-size integers and these
are used for multiple purposes. In \ATALe every machine word have been tagged
with their intended usage. While any machine word can still be copied or
overwritten additional operations are only defined for some tags:

\begin{itemize}
\item Words tagged as numbers can be used for arithmetics.
\item Words tagged as pointers can only be used to dereference memory. Depending
  on the pointer, this dereference could be a read or a write.
\item Words tagged as uninitialized does not have any additional operations.
\end{itemize}

Another difference is that instructions are no longer decoded machine
words. Instead they are collected into pre-decoded basic blocks. A basic block
is an immutable series of instructions that ends with an unconditional jump or a
halt instruction.

Memory is no longer a continuous array of machine words. Instead it has been
split into three parts each with difference functions:

\begin{itemize}
\item The global values/globals is where code is stored. It is a collection of
  basic blocks. The only operation supported by the global values is to fetch a
  specific basic block.
\item The heap is where long-lived mutable data lives. It is a collection of
  tuples, where each tuple is a collection of machine words. It supports three
  operations: allocating a new tuple of a given size along with reading/write a
  machine word given a pointer to a tuple and a tuple-index. It does not support
  deallocating tuples. This is an unfortunate part of our model, and we will in
  \Cref{chap:safesound} discuss this problem including how to partially mitigate
  it by using garbage collection.
\item The stack is where short-lived mutable data lives. It is a collection of
  machine words. It supports four operations: Adding a number of uninitialized
  machine words to the top of the stack, deallocating a number of machine words
  (no matter their tag) from the top of the stack, reading or writing a machine
  words indexes by distance from the top of the stack.
\end{itemize}

The registers are still a collection of machine words with the exception of the
special-purpose register \texttt{sp}. This register is no longer a machine word,
but instead always points to the top of the stack.

In addition to splitting memory, we will also restrict the possible values a
pointer can take. A pointer can only point to the beginning of a heap-tuple or
to the beginning of a basic block\footnote{On the surface this seems to disallow
  some cases of code re-use, however it turns out to not be so much of a problem
  in practice. If we wanted to refer to some point in the middle of a basic
  block, then we could simply split it and insert an unconditional jump at the
  end of the first block. We might even make this jump implicit to avoid wasting
  space.}. Machine words cannot point to the stack; the only reference to the
stack is \texttt{sp}.

Finally the issue of memory organization have been abstracted away. It is no
longer meaningful to talk about the ``location'' of values in memory. As an
example the stack is neither below nor above the heap, it simply \emph{is}.  An
indirect consequence of this is also that memory is effectively infinite in our
model. This has some interesting consequences for the relation to the real-world
model which we will discuss in \Cref{chap:safesound}. Until then we will ignore
the issue by staying inside our models.

\subsection{Additional differences introduced by \ATAL}

The \ATAL model goes a step further by introducing a type system, which is used
during the run-time. The fundamental concept is that of a \emph{type}. Some
informal examples of types are ``integer'', ``basic block taking an integer as
argument'' or ``tuple of two integers''. This type system includes the
parametric polymorphism and subtyping. The only types that are allowed to be
polymorphic is the types of basic blocks.

In \ATAL all basic blocks and tuples have a type associated with them. This
associated type is superficially similar to the tag added to machine words. The
biggest difference is that the tags for machine words matter at run-time, while
the associated types do not.

Another change with \ATAL is that places where one could refer to a basic block
(such as inside an instruction or word value), one can now \emph{additionally}
add generalization and instantiation information to the value.

\section{Grammar for \ATALe}

Before introducing \ATAL, let us introduce \ATALe, as it is simpler and better
captures the intended meaning of the language. The language itself is a set of
states. In the Agda-implementation uses a context-free grammar for this, though
the version presented here is strictly speaking not context free, as it uses
dictionaries.

{\footnotesize
\begin{tabular}{lrcl}
Variables: \\
\textit{global pointers} & $\ell_{\mathrm{g}}$ \\
\textit{heap pointers}   & $\ell_{\mathrm{h}}$ \\\\

Common definitions: \\
\textit{integer}            & $n,k$ & ::= & $0, 1, \dots$ \\
\textit{machine integers}   & $i$   & ::= & $0, 1, \dots, 2^{\mathrm{wordsize}}-1$ \\
\textit{registers}          & $r$   & ::= & $\mathtt{r}_1 \mid \dots \mid \mathtt{r}_{\mathrm{max}}$ \\\\

The grammar for \ATALe: \\
\textit{word values}        & $\simple w$ & ::= & $\mathtt{globval}\ \ell_{\mathrm{g}} \mid \mathtt{heapval}\ \ell_{\mathrm{h}} \mid \mathtt{int}\ i \mid \mathtt{uninit}$ \\
\textit{small values}       & $\simple v$ & ::= & $\mathtt{globval}\ \ell_{\mathrm{g}} \mid \mathtt{reg}\ r \mid \mathtt{int}\ i$ \\
\textit{global values}      & $\simple g$ & ::= & $\mathtt{code}\ \simple I$ \\
\textit{global collections} & $\simple G$ & ::= & $\{\ell_{\mathrm{g}} |-> \simple{g}, \dots, \ell_{\mathrm{g}} |-> \simple{g}\}$ \\
\textit{heap values}        & $\simple h$ & ::= & $\mathtt{tuple}\ \langle \simple w, \dots, \simple w \rangle$ \\
\textit{heap collections}   & $\simple H$ & ::= & $\{\ell_{\mathrm{h}} |-> \simple{h}, \dots, \ell_{\mathrm{h}} |-> \simple{h}\}$ \\
\textit{stacks}             & $\simple S$ & ::= & $\nil \mid \simple w :: \simple S$ \\
\textit{register files}     & $\simple R$ & ::= & $\{\mathtt{sp} |-> \simple{S}, \mathtt{r}_1 |-> \simple{w}, \dots, \mathtt{r}_{\mathrm{max}} |-> \simple{w}\}$ \\\\

\textit{instructions} & $\simple \iota$ & ::= & $\mathtt{add}\ r, r, \simple v \mid \mathtt{sub}\ r, r, \simple v \mid$ \\
        &&& $\mathtt{salloc}\ n \mid \mathtt{sfree}\ n \mid$ \\
        &&& $\mathtt{ld}\ r, \mathtt{sp}(n) \mid \mathtt{ld}\ r, r(n) \mid$ \\
        &&& $\mathtt{st}\ \mathtt{sp}(n), r \mid \mathtt{st}\ r(n), r \mid$ \\
        &&& $\mathtt{malloc}\ r,\ n \mid $ \\
        &&& $\mathtt{mov}\ r, \simple v \mid \mathtt{beq}\ r, \simple v$ \\
\textit{instruction sequences} & $\simple I$ & ::= & $\simple\iota ; \simple I \mid \mathtt{jmp}\ \simple v \mid \mathtt{halt}$ \\
\textit{program states} & $\simple P$ & ::= & $(\simple G, \simple H, \simple R, \simple I)$ \\\\
\end{tabular}
}

There is only one major differences between this version and the one in
\texttt{Judgments/SimpleGrammar.agda}, and that is the issue of the dictionaries
and variables. In the presented version we simply assumed an infinite number of
variables
$\ell_{\mathrm{g},0}, \ell_{\mathrm{h},0}, \ell_{\mathrm{g},1}, \dots$, and
created dictionaries using these variables as keys.

This approach is not suitable in the Agda-version, as the Agda-version uses a
context-free grammar. Instead we will assign these abstract variables to natural
numbers. This means that we can use ordered lists instead of dictionaries, and
ordered lists can be represented using a context-free grammar.

For instance: The globals collection
$\{\ell_{\mathrm{g},0} |-> g_{\mathrm{e},0}, \ell_{\mathrm{g},1} |->
h_{\mathrm{e},1}\}$ could be represented in the Agda-code by the list
$h_{\mathrm{e},0} :: h_{\mathrm{e},1} :: \mathtt{nil}$ in which case we would
have $\ell_{\mathrm{g},0} = 0, \ell_{\mathrm{g},1} = 1$. The other valid choice
would be $h_{\mathrm{e},1} :: h_{\mathrm{e},0} :: \mathtt{nil}$, but in this
case we must have $\ell_{\mathrm{g},0} = 1, \ell_{\mathrm{g},1} = 0$.

[Expand more. Do not assume the reader knows what you are doing or trying to do.]

\section{Grammar for \ATAL}

The grammar for \ATAL is very similar. There are very few syntactic
differences (besides the addition of the type system itself):

\begin{itemize}
\item Global values have had a type added to them. This type is only added as
  hint to the type-checker -- it is not actually used at run-time. This type is
  added to specify which generics a basic block supports.
\item Heap values have had a type added to them as well. These types only have
  relevance for the \texttt{malloc} instruction -- and even then they do not
  affect any other aspects of the run-time.
\item Instantiations have been added to word values and small values. This
  syntax is used to instantiate the type variables of a basic block.
\item The \texttt{malloc} instruction no longer takes a number as the second
  argument. Instead it takes a list of types.
\end{itemize}

{\footnotesize
\begin{tabular}{lrcl}
Variables: \\
\textit{global pointers} & $\ell_{\mathrm{g}}$ \\
\textit{heap pointers}   & $\ell_{\mathrm{h}}$ \\
\textit{type variable}   & $\alpha$ \\
\textit{stack variable}  & $\rho$ \\\\

Common definitions: \\
\textit{integer}            & $n,k$ & ::= & $0, 1, \dots$ \\
\textit{machine integers}   & $i$   & ::= & $0, 1, \dots, 2^{\mathrm{wordsize}}-1$ \\
\textit{registers}          & $r$   & ::= & $\mathtt{r}_1 \mid \dots \mid \mathtt{r}_{\mathrm{max}}$ \\\\

The type system for \ATAL: \\
\textit{types}                    & $\tau$ & ::= & $\alpha \mid \mathtt{int} \mid \mathtt{ns} \mid \mathtt\forall[ \Delta ] \Gamma \mid \langle\tau^\phi,\dots,\tau^\phi\rangle$ \\
\textit{initialization flags}     & $\phi$ & ::= & $\mathtt{init} \mid \mathtt{uninit}$ \\
\textit{stack types}              & $\sigma$ & ::= & $\rho \mid \nil \mid \tau :: \sigma$ \\
\textit{type assignments}         & $\Delta$ & ::= & $\nil \mid a :: \Delta$ \\
\textit{type assignment value}    & $a$ & ::= & $\alpha \mid \rho$ \\
\textit{global label assignments} & $\Psi_{\mathrm{g}}$ & ::= & $\{\ell_{\mathrm{g}} |-> \tau, \dots, \ell_{\mathrm{g}} |-> \tau\}$ \\
\textit{heap label assignmentss}  & $\Psi_{\mathrm{h}}$ & ::= & $\{\ell_{\mathrm{h}} |-> \tau, \dots, \ell_{\mathrm{h}} |-> \tau\}$ \\
\textit{register assignments}     & $\Gamma$ & ::= & $\{\mathtt{sp} |-> \sigma, \mathtt{r}_1 |-> \tau, \dots, \mathtt{r}_{\mathrm{max}} |-> \tau\}$ \\
\textit{instantiation}            & $\theta$ & ::= & $\tau/\alpha \mid \sigma/\rho$ \\
\textit{instantiations}           & $\Theta$ & ::= & $\theta :: \Theta \mid \nil$ \\\\

The grammar for \ATAL itself: \\
\textit{word values}              & $\high w$ & ::= & $\mathtt{globval}\ \ell_{\mathrm{g}} \mid \mathtt{heapval}\ \ell_{\mathrm{h}} \mid \mathtt{int}\ i \mid \mathtt{uninit} \mid \Lambda\ \Delta \cdot \high{w}[\Theta]$ \\
\textit{small values}             & $\high v$ & ::= & $\mathtt{globval}\ \ell_{\mathrm{g}} \mid \mathtt{reg}\ r \mid \mathtt{int}\ i \mid \Lambda\ \Delta \cdot \high{v}[\Theta]$ \\
\textit{global values}            & $\high g$ & ::= & $\mathtt{code}[ \Delta ] \Gamma \cdot \high I$ \\
\textit{global collections}       & $\high G$ & ::= & $\{\ell_{\mathrm{g}} |-> \high{g}, \dots, \ell_{\mathrm{g}} |-> \high{g}\}$ \\
\textit{heap values}              & $\high h$ & ::= & $\mathtt{tuple}\ \langle \tau, \dots, \tau \rangle\ \langle \high w, \dots, \high w \rangle$ \\
\textit{heap collections}         & $\high H$ & ::= & $\{\ell_{\mathrm{h}} |-> \high{h}, \dots, \ell_{\mathrm{h}} |-> \high{h}\}$ \\
\textit{stacks}                   & $\high S$ & ::= & $\nil \mid \high w :: \high S$ \\
\textit{register files}           & $\high R$ & ::= & $\{\mathtt{sp} |-> \high{S}, \mathtt{r}_1 |-> \high{w}, \dots, \mathtt{r}_{\mathrm{max}} |-> \high{w}\}$ \\\\

\textit{instructions} & $\high\iota$ & ::= & $\mathtt{add}\ r, r, \high v \mid \mathtt{sub}\ r, r, \high v \mid$ \\
        &&& $\mathtt{salloc}\ n \mid \mathtt{sfree}\ n \mid$ \\
        &&& $\mathtt{ld}\ r, \mathtt{sp}(n) \mid \mathtt{ld}\ r, r(n) \mid$ \\
        &&& $\mathtt{st}\ \mathtt{sp}(n), r \mid \mathtt{st}\ r(n), r \mid$ \\
        &&& $\mathtt{malloc}\ r,\ \langle \tau, \dots, \tau \rangle \mid $ \\
        &&& $\mathtt{mov}\ r, \high v \mid \mathtt{beq}\ r, \high v$ \\
\textit{instruction sequences} & $\high I$ & ::= & $\high\iota ; \high I \mid \mathtt{jmp}\ \high v \mid \mathtt{halt}$ \\
\textit{program states} & $\high P$ & ::= & $(\high G, \high H, \high R, \high I)$ \\
\end{tabular}
}

As we did for \ATALe, we will used natural numbers to represent the variables in
\ATAL. $\ell_{\mathrm{g}}$ and $\ell_{\mathrm{h}}$ will be handled using the
same technique, while $\alpha$ and $\rho$ will be represented using De Bruijn
indices.

[Expand more. Do not assume the reader knows what you are doing or trying to do.]

\section{Semantics for \ATAL}

This brings us to the semantics for \ATAL. There are a few different judgments
used:

\begin{tabular}{|c|p{7.5 cm}|}
  \hline
  Judgment & \multicolumn{1}{|c|}{Meaning} \\\hline
  $\evalregs{\high R}{\high v}{\high w}$ & Here $\high v$ is a small value, that is used an argument to an instruction. This judgment states that we can evaluate $v$ to $\high w$ by looking up registers in the register file $\high R$. \\\hline
  $\evalcode{\high G}{\high w}{I}$ & Here $\high w$ is a word value that we intend to jump to. This judgment states that we can evaluate $\high w$ to the basic block $\high I$ by looking up basic blocks in $\high G$ and possibly instantiating some of the type variables. \\\hline
  $\execis{\high G}{\high H, \high R, \high I}{\high H', \high R', \high I'}$ & This is our main small-step relation. It is a judgment that asserts that if a program is in state $(\high G, \high H, \high R, \high I)$, then it can transition to $(\high G, \high H', \high R', \high I')$. Note that $G$ is immutable. \\\hline
  $\steps{\high P}{\high P'}$ & This states that the program state $\high P$ can small-step to $\high P'$. It has only a single rule which uses the judgment above. \\\hline
  $\stepsn{\high P}{n}{\high P'}$ & This states that the program state $\high P$' can small-step to $\high P'$ in $n$ steps. \\\hline
\end{tabular} \\

Let us start with the last two judgments as they are the simplest: \\

\fbox{$\steps{\high P}{\high P'}$}
\begin{mathpar}
  \infer{
    \execis{\high G}{(\high H, \high R, \high I)}{(\high H', \high R', \high I')}
  }{
    \steps{(\high G, \high H, \high R, \high I)}{(\high G, \high H', \high R', \high I')}
  }
\end{mathpar}

\fbox{$\stepsn{\high P}{n}{\high P'}$}
\begin{mathpar}
  \infer{
  }{
    \stepsn{\high P}{0}{\high P}
  } \and
  \infer{
    \steps{\high P}{}{\high P'} \and
    \stepsn{\high P'}{n}{\high P''}
  }{
    \stepsn{\high P}{1+n}{\high P''}
  }
\end{mathpar}

The definition for $\evalregs{\high R}{\high v}{\high w}$ is also pretty simple --
it simply replaces \texttt{reg}-values by looking up the register in the
register file: \\

\fbox{$\evalregs{\high R}{\high v}{\high w}$}
\begin{mathpar}
  \infer{
  }{
    \evalregs{\high R}{\mathtt{reg}\ r}{\high R[r]}
  } \and
  \infer{
  }{
    \evalregs{\high R}{\mathtt{globval}\ \ell_{\mathrm{g}}}{\mathtt{globval}\ \ell_{\mathrm{g}}}
  } \and
  \infer{
  }{
    \evalregs{\high R}{\mathtt{int}\ i}{\mathtt{int}\ i}
  } \and
  \infer{
    \evalregs{\high R}{\high v}{\high w}
  }{
    \evalregs{\high R}{\Lambda\ \Delta \cdot \high{v}[\Theta]}{\Lambda\ \Delta \cdot \high{w}[\Theta]}
  }
\end{mathpar}

\fbox{$\evalcode{\high G}{\high w}{I}$}
\begin{mathpar}
\infer{
  \high G[\ell_{\mathrm{g}}] = \mathtt{code}[ \Delta ] \Gamma \cdot \high I
}{
  \evalcode{\high G}{\mathtt{globval}\ \ell_{\mathrm{g}}}{\high I}
} \and
\infer{
  \evalcode{\high G}{w}{\high I} \\
  \high I_1 = \high I[x_1 / a_1] \and \dots \and \high I_n = \high I_{n-1}[x_n / a_n] \\
  \text{(this should be interpreted as recursively substituting $a_k$ with $x_k$ inside the values)} \\
  \\
}{
  \evalcode{\high G}{\Lambda\ \Delta \cdot \high w[x_1 / a_1, \dots, x_n / a_n]}{\high I_n}
}
\end{mathpar}

\fbox{$\execis{\high G}{\high H, \high R, \high I}{\high H', \high R', \high I'}$}
\begin{mathpar}
\infer{
  \high R[r_b] = \mathtt{int}\ i_1 \and
  \evalregs{\high R}{\high v}{\mathtt{int}\ i_2}
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{add}\ r_a, r_b, \high v) ; \high I}
    {\high H, \high R[r_a \mapsto \mathtt{int}\ (i_1 + i_2)], \high I}
} \and
\infer{
  \high R[r_b] = \mathtt{int}\ i_1 \and
  \evalregs{\high R}{\high v}{\mathtt{int}\ i_2}
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{sub}\ r_a, r_b, \high v) ; \high I}
    {\high H, \high R[r_1 \mapsto \mathtt{int}\ (i_1 - i_2)], \high I}
} \and
\infer{
  \high S = \overbrace{\mathtt{uninit} :: \dots :: \mathtt{uninit}}^n :: \high R[\mathtt{sp}]
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{salloc}\ n) ; \high I}
    {\high H, \high R[\mathtt{sp} |-> \high S], \high I}
} \and
\infer{
  \high R[\mathtt{sp}] = \overbrace{\high w_1 :: \dots :: \high w_n}^n :: \high S
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{sfree}\ n) ; \high I}
    {\high H, \high R[\mathtt{sp} |-> \high S], \high I}
} \and
\infer{
  \high R[\mathtt{sp}][n] = \high w
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{ld}\ r, \mathtt{sp}(n)) ; \high I}
    {\high H, \high R[r |-> \high w], \high I}
} \and
\infer{
  \high R[r_b] = \mathtt{heapval}\ \ell_{\mathrm{h}} \and
  \high H[\ell_{\mathrm{h}}] = \mathtt{tuple}\ \langle \tau_1, \dots \rangle\ \langle \high w_1, \dots, \high w_n, \dots \rangle
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{ld}\ r_a, r_b(n)) ; \high I}
    {\high H, \high R[r_a |-> \high w_n], \high I}
} \and
\infer{
  R[r] = \high w \and
  R[\mathtt{sp}] = \high S
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{st}\ \mathtt{sp}(n), r) ; \high I}
    {\high H, \high R[\mathtt{sp} |-> \high S[n |-> \high w]], \high I}
} \and
\infer{
  \high R[r_a] = \mathtt{heapval}\ \ell_{\mathrm{h}} \and
  \high H[\ell_{\mathrm{h}}] = \mathtt{tuple}\ \langle \tau_1, \dots \rangle\ \langle \high w_1, \dots \high w_n, \dots \rangle \and
  \high R[r_b] = \high w \and
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{st}\ r_a(n), r_b) ; \high I}
    {\high H[\ell_{\mathrm{h}} |-> \mathtt{tuple}\ \langle \tau_1, \dots, \rangle\ \langle \high w_1, \dots, w, \dots \rangle], \high R, \high I}
} \and
\infer{
  \text{$\ell_{\mathrm{h}}$ is a fresh variable} \and
  \high h = \mathtt{tuple}\ \langle \tau_1, \dots, \tau_n \rangle\ \overbrace{\langle \mathtt{uninit}, \dots, \mathtt{uninit} \rangle}^n
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{malloc}\ r, \langle \tau_1, \dots, \tau_n \rangle) ; \high I}
    {\high H \cup \{\ell_{\mathrm{h}} |-> \high h\}, R[r |-> \mathtt{heapval}\ \ell_{\mathrm{h}}], \high I}
} \and
\infer{
  \evalregs{\high R}{\high v}{\high w}
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{mov}\ r, \high v) ; \high I}
    {\high H, \high R[r |-> \high w], \high I}
} \and
\infer{
  \high R[r] = \mathtt{int}\ 0 \and
  \evalregs{\high R}{\high v}{\high w} \and
  \evalcode{\high G}{\high w}{I'}
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{beq}\ r, \high v) ; \high I}
    {\high H, \high R, \high I'}
} \and
\infer{
  \high R[r] = \mathtt{int}\ i \and
  i \neq 0
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{beq}\ r, \high v) ; \high I}
    {\high H, \high R, \high I}
} \and
\infer{
  \evalregs{\high R}{\high v}{\high w} \and
  \evalcode{\high G}{\high w}{I}
}{
  \execis{\high G}
    {\high H, \high R, \mathtt{jmp}\ \high v}
    {\high H, \high R, \high I}
}
\end{mathpar}

\section{Semantics for \ATALe}

The semantics for \ATALe er mostly the same as for \ATAL -- it has the same 5
core judgments as. The difference are:

\begin{itemize}
\item $\evalregs{\simple R}{\simple v}{\simple w}$ has one case less than
  $\evalregs{\high R}{\high v}{\high w}$ because \ATALe does not have the
  instantiation syntax.
\item For the same reason there is only fewer case for
  $\evalcode{\simple G}{\simple w}{\simple I}$. Note that this makes the
  judgment almost trivial.
\item
  $\execis{\simple G}{\simple H, \simple R, \simple I}{\simple H', \simple R',
    \simple I'}$ has changed slightly. The cases for $\mathtt{ld}\ r_a, r_b(n)$
  and $\mathtt{st}\ r_a(n), r_b$ have been simplified in the obvious way as
  tuples do not carry type information. The case for $\mathtt{malloc}$ has also
  been changed slightly:
\end{itemize}

\begin{mathpar}
\infer{
  \text{$\ell_{\mathrm{h}}$ is a fresh variable} \and
  \simple h = \mathtt{tuple}\ \overbrace{\langle \mathtt{uninit}, \dots, \mathtt{uninit} \rangle}^n
}{
  \execis{\simple G}
    {\simple H, \simple R, (\mathtt{malloc}\ r, n) ; \simple I}
    {\simple H \cup \{\ell_{\mathrm{h}} |-> \simple h\}, R[r |-> \mathtt{heapval}\ \ell_{\mathrm{h}}], \simple I}
} \and
\end{mathpar}

\section{Proof of erasure}
\label{sec:erasure}

% % Informally
% % this means that the languages are essentially equivalent, however there are two
% % good reasons for introducing it anyways:


% % A fundamental abstraction in \ATAL (and other TAL-based systems) is the
% % basic-block. A basic-block is a collection of instructions with two properties:

% % \begin{itemize}
% % \item There can only be references to the start of a basic-block, not into the
% %   middle of one.
% % \item A basic block will always contain exactly one unconditional jump or halt,
% %   and that is the last instruction of the block.\footnote{Note that it is often
% %     beneficial to weaken this assumption slightly, by also allowing an
% %     \emph{implicit} unconditional jump to the basic-block at the next
% %     address. We will not allow that in our definition, but could easily emulate
% %     it.}
% % \end{itemize}

% % A program-state in \ATAL is a tuple $\langle G, H, R, I \rangle$ consisting of
% % \textbf{global values}, \textbf{heap values}, \textbf{register values} and
% % \textbf{the current basic-block}. In \ATAL a global value is always a
% % type-annotated basic-block, but it could be extended with other global values. A
% % heap value is always a tuple of word-sized values (though it could be a tuple of
% % size 1). In Agda we implement these collections as ordered lists, however other
% % constructions such as dictionaries could be used.

% % The register values is a mapping from register names to a word values -- the
% % only exception is the stack pointer, which is mapped to a stack of word values
% % (again implemented as an ordered list).

% % We will then define a small-step semantics, which is a relation from
% % program-states to program-states.


% % \begin{itemize}
% % \item \ATAL depends on types at run-time for its execution. while \ATALe does
% %   not. Since the two languages are essentially equivalent, one can simply
% %   translate from \ATAL to \ATALe before running the program.
% % \item \ATALe is much simpler than \ATAL. This makes it easier to reason about
% %   any implementation that runs \ATALe-code.
% % \item It makes it possible to experiment with changes to \ATAL without changing
% %   \ATALe or the system that runs \ATALe-code.
% % \end{itemize}
