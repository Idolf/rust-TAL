\chapter{\ATAL and \ATALe}
\label{chap:lang}

As stated in \cref{sec:goal}, we want to design a secure sandbox. To do so we
will design a Typed Assembly Language and prove its soundness. In this chapter
we will introduce the two languages in which we will build this sandbox. We will
do this by:

\begin{itemize}
\item Defining \ATAL and \ATALe in terms of their program states.
\item The set of possible program states are defined in terms a syntax. In our
  Agda formalization this syntax is specified by a collection of inductive data
  types. In our paper definition, we have chosen to use some slightly more
  advanced syntax for increased readability. As we shall see, this is not a
  problem as there is a trivial correspondence between the two presentations.
\item We will present a small-step semantics for the two languages and prove
  that they are related by the erasure property.
\end{itemize}

The full implications of and reasoning behind having two languages related by
erasure will be discussed later. \Cref{chap:erasure} will discuss some of the
issues along with the proof, while the full reasoning will not be apparent until
\Cref{chap:safesound}. For now we will simply postulate two advantages of this
approach over the alternative of using a single language:

\begin{itemize}
\item By having two languages we are mostly able to separate our type system
  from our model simplification. This would ideally make our presentation
  easier, but it is also an advantage when reasoning about the sandbox
  implementation.
\item This separation also allows one to experiment with different type systems:
  If the experimental type system is sound, decidable and has the erasure
  property, then it can potentially use the same sandbox infrastructure. In fact
  a single sandbox implementation might have multiple type-checkers, if some
  features turn out to be incompatible in the type system.
\end{itemize}

Before formally defining the languages, we will give an informal understanding
of our model by comparing it to real-world CPUs.

\section{Syntax for \ATALe}

Before introducing \ATAL, let us introduce \ATALe. It is both simpler and better
captures the intended meaning of the language. The syntax for \ATALe is
presented in \cref{fig:esyntax}. To understand this syntax, it is useful to
compare it real-world CPUs.

Most real-world CPUs use some kind of a von Neumann architecture. In (a
simplified version of) the von Neumann architecture, you only have memory and
registers each holding some number of machine words. Additionally you need a
procedure to fetch, decode and execute the current instruction from memory by
using a special-purpose register called the instruction pointer. This execution
might change either memory or registers. To run the CPU simply, we repeats the
execution procedure indefinitely.

In this architecture there are only two conceptual abstractions: Machine words
are fixed-width integers and instructions are just decoded machine words. This
simplicity makes it easier to implement and analyze CPU designs, however it
makes hard to analyze programs.

As in the von Neumann architecture \ATALe consists of program states that can
transition to each other. However these states are somewhat more complicated, as
a number of new concepts are introduced. Machine words are in our model
represented by \emph{word values}. These are not the simple fixed-width numbers
from the von Neumann architecture, instead there are a number of different
constructions distinguished by a tag. This tag is only present in our model;
when translating to a real-world CPU, the tag will be discarded. All word values
can be copied or overwritten, however other uses depend on the tag:

\begin{itemize}
\item Words tagged with \texttt{int} are numbers and can be used for
  arithmetic.
\item Words tagged with \texttt{globval} are pointers to code. We can use these
  pointers as destination for code branching.
\item Words tagged with \texttt{heapval} are pointers to mutable data. We can
  use these pointers to read or write data.
\item Words tagged with \texttt{uninit} are uninitialized. They occur for
  instance when allocating a new tuple or when allocating space on the
  stack. They cannot be used for anything (besides being copied or overwritten).
\end{itemize}

Another difference is that instructions are no longer machine words decoded at
run-time. Instead they are pre-decoded and are organized into basic blocks. A
basic block is an immutable series of instructions that ends with a \texttt{jmp}
or \texttt{halt} instruction. It should be noted that we have included an
instruction that is not typically encoded directly in the CPU, namely
\texttt{malloc}. When translating to the real-world CPU, this will require
assistance from a memory manager. Since we have not included a
\texttt{free}-instruction, it will also require a garbage collector if we wish
to avoid memory leaks.

The \emph{global collections} are where we store immutable, global data. In our
model there is only one type of global value: code organized into basic
blocks. Our \texttt{global}-pointers will always point to the beginning of a
global value. Initially this might seem restrictive, as it prevents some forms
of code re-use, but it turns out to not be a problem in practice. If we wanted
to refer to some point in the middle of a basic block, then we could simply
split it and insert an unconditional jump at the end of the first block. We
might even make this jump implicit to avoid wasting space.

\begin{figure}
  {\footnotesize
    \begin{tabular}{lrcl}
      Variables: \\
      \textit{global pointers} & $\ell_{\mathrm{g}}$ \\
      \textit{heap pointers}   & $\ell_{\mathrm{h}}$ \\\\

      Common definitions: \\
      \textit{integer}            & $n$ & ::= & $0, 1, \dots$ \\
      \textit{machine integers}   & $i$ & ::= & $0, 1, \dots, 2^{\mathrm{wordsize}}-1$ \\
      \textit{registers}          & $r$ & ::= & $\mathtt{r}_1 \mid \dots \mid \mathtt{r}_{\mathrm{max}}$ \\\\

      The syntax for \ATALe: \\
      \textit{word values}        & $\simple w$ & ::= & $\mathtt{int}\ i \mid \mathtt{globval}\ \ell_{\mathrm{g}} \mid \mathtt{heapval}\ \ell_{\mathrm{h}} \mid \mathtt{uninit}$ \\
      \textit{small values}       & $\simple v$ & ::= & $\mathtt{int}\ i \mid \mathtt{globval}\ \ell_{\mathrm{g}} \mid \mathtt{reg}\ r$ \\
      \textit{global values}      & $\simple g$ & ::= & $\mathtt{code}\ \simple I$ \\
      \textit{heap values}        & $\simple h$ & ::= & $\mathtt{tuple}\ \langle \simple w, \dots, \simple w \rangle$ \\
      \textit{stacks}             & $\simple S$ & ::= & $\nil \mid \simple w :: \simple S$ \\
      \textit{instructions} & $\simple \iota$ & ::= & $\mathtt{add}\ r, r, \simple v \mid \mathtt{sub}\ r, r, \simple v \mid$ \\
                               &&& $\mathtt{salloc}\ n \mid \mathtt{sfree}\ n \mid$ \\
                               &&& $\mathtt{ld}\ r, \mathtt{sp}(n) \mid \mathtt{ld}\ r, r(n) \mid$ \\
                               &&& $\mathtt{st}\ \mathtt{sp}(n), r \mid \mathtt{st}\ r(n), r \mid$ \\
                               &&& $\mathtt{malloc}\ r,\ n \mid $ \\
                               &&& $\mathtt{mov}\ r, \simple v \mid \mathtt{beq}\ r, \simple v$ \\
      \textit{instruction sequences} & $\simple I$ & ::= & $\simple\iota ; \simple I \mid \mathtt{jmp}\ \simple v \mid \mathtt{halt}$ \\\\

      \textit{global collections} & $\simple G$ & ::= & $\{\ell_{\mathrm{g}} |-> \simple{g}, \dots, \ell_{\mathrm{g}} |-> \simple{g}\}$ \\
      \textit{heap collections}   & $\simple H$ & ::= & $\{\ell_{\mathrm{h}} |-> \simple{h}, \dots, \ell_{\mathrm{h}} |-> \simple{h}\}$ \\
      \textit{register files}     & $\simple R$ & ::= & $\{\mathtt{sp} |-> \simple{S}, \mathtt{r}_1 |-> \simple{w}, \dots, \mathtt{r}_{\mathrm{max}} |-> \simple{w}\}$ \\
      \textit{program states} & $\simple P$ & ::= & $(\simple G, \simple H, \simple R, \simple I)$ \\\\
    \end{tabular}
  }
  \caption{The syntax for \ATALe}
  \label{fig:esyntax}
\end{figure}

We store long-lived, mutable data in the \emph{heap collection}; specifically
our only type of heap value is a tuple of word values. Again we will only allow
pointers to the beginning of objects, so \texttt{heapval}-pointers always point
to an entire tuple. This will prevent some useful programs from being
represented in our model. It should be possible to extend the model to allow
this, however doing so is outside the scope of this thesis.

The \emph{stack} is used for short-lived, mutable data. There can be no pointers
to the stack; we only reference the stack directly through offsets from the top
of the stack, which is saved in the register \texttt{sp}. Besides reading or
writing through indexing of the stack, we have instructions for allocating and
deallocating word values from the stack.

\emph{Small value} are arguments used as part of some instructions. These
arguments can refer either to registers, constant integers or be code
pointers. This allows us to write e.g.
$\mathtt{add}\ r_a, r_b, \mathtt{reg}\ r_c$ and
$\mathtt{add}\ r_a, r_b, \mathtt{int}\ i$. A small value can be thought of as a
description of how to generate a particular word value when the code is
executed.

Finally we can state that \emph{program states} in \ATALe consists of a global
collection, a heap collection, a register file and the current block. This is
different from the von Neumann architecture, where states are simply some
registers and some memory. While certainly more complicated, one could also
argue that \ATALe is in a sense a specialization of the von Neumann
architecture:

\begin{itemize}
\item Memory have been split up and specialized for different use-cases.
\item A register have been dedicated to the stack. It will always point to the
  top of the stack, and it is in fact the only reference to the stack.
\item The instruction pointer have been similarly specialized. Instead of
  pointer into memory, we hold a reference to the remainder of the current basic
  block.
\end{itemize}

\subsection{Notes on the Agda implementation}

Our Agda-version of this syntax is implemented in the
\texttt{Judgments/SimpleSyntax.agda}, and it is very close to the above
presentation. Most of the above syntax can be represented directly in Agda using
inductive data types. The exception to this is that we have used dictionaries
and variables drawn from infinite, enumerable sets. Neither of these can be
represented directly in Agda.

We solve these problems by representing the variables and registers using
natural numbers. This means that we can use ordered lists instead of
dictionaries, and ordered lists can be represented directly in Agda. The globals
collection
$\{\ell_{\mathrm{g},0} |-> g_{\mathrm{e},0}, \ell_{\mathrm{g},1} |->
h_{\mathrm{e},1}\}$ could for instance be represented in the Agda-code by the
list $h_{\mathrm{e},0} :: h_{\mathrm{e},1} :: \mathtt{nil}$ in which case we
would have $\ell_{\mathrm{g},0} = 0, \ell_{\mathrm{g},1} = 1$. The other valid
choice would be $h_{\mathrm{e},1} :: h_{\mathrm{e},0} :: \mathtt{nil}$, but in
this case we have $\ell_{\mathrm{g},0} = 1, \ell_{\mathrm{g},1} = 0$.

This difference between the two versions is of no particular importance, and it
exists mostly for readability and to conform with earlier papers (see
\cref{sec:rel-stal}). There are however two interesting consequences of the
differences:

\begin{itemize}
\item It is at this point worth emphasizing that terms that are equal in our
  paper-notation might not be equal in the Agda-representation (though the
  reverse direction holds). In fact, we have just seen an example where this is
  the case. Luckily, this difference will have no real consequence, as our
  results does not depend on it.
\item Some of the lemmas proven in the Agda-code will be very hard to even state
  when using the paper notation. This will be particularly noticeable after we
  introduce variable substitution in \ATAL. Luckily these lemmas are not
  themselves particularly interesting; they are simply needed for other
  results. We will mostly bypass this issue by leaving out trivial lemmas and
  stating the non-trivial ones in a slightly informal fashion.
\end{itemize}

\subsection{Lemmas}

At this point, we are already able to prove lemmas about our syntax. In the file
\texttt{Lemmas/Equality.agda} we prove this:

\begin{lemma}
  Given two program states $\simple{P}, \simple{P'}$ we can decide whether we
  have $\simple P = \simple{P'}$ or $\simple P \neq \simple{P'}$. Similar
  statements hold for the other syntactic classes.
\end{lemma}

The equality referred to in the above lemma is syntactic equality in the Agda
notation, which as previously mentioned will even distinguish between some
objects that are equal in the paper-notation. Since we are representing our
variables using natural numbers, this is equivalent to equality up to alpha
conversion (but not up to reordering the content of dictionaries).

This lemma is trivial in the sense that it can be proven for any inductively
defined datatype. We still mention it, because it is not automatically derived
in Agda. The naive approach to implementing it in Agda would use structural
induction over both arguments. This has the disadvantage, that it often results
in very long proofs, specifically a quadratic number\footnote{Quadratic in the
  number of constructors for the datatype.} of lines. We have instead chosen to
use a more space-efficient solution, which involves using an injective function
to another datatype. See \cref{sec:deceq} for more details.

\section{Syntax for \ATAL}

The syntax for \ATAL is presented \cref{fig:syntax} and is very similar to that
of \ATALe. The biggest addition is the type system which is present during the
run-time. This type system includes the parametric polymorphism and subtyping.

\todo{Explain parametric polymorphism and subtyping.}
\todo{Explain $\alpha$, $\rho$.}

\begin{itemize}
\item The \emph{base types} are best thought of as the types of word values and
  small values. It also reused for global values and heap values, though these
  only use a subset of the possible types (specifically function types and tuple
  types). Some informal examples of types encodable in this system are ``an
  integer'', ``a basic block taking an integer as argument'' or ``a tuple of two
  integers''. \todo{Write something similar to: The syntax
    $\forall[\Delta] \Gamma$ should be interpreted as the type of a basic block
    with type parameters $\Delta$ taking registers with types $\Gamma$. This
    could intuitively be interpreted as a function taking $\Gamma$ as an
    argument and never returning.}
\item \emph{Type assignments} are the assumptions used in types. They are used
  for parametric polymorphism.
\item \emph{Stack types} are the type of stacks.
\item \emph{Global label assignments} are the types of global collections.
\item \emph{Heap label assignments} are the types of heap collections.
\item \emph{Register assignments} are the types of register files.
\item An \emph{instantiation} is an encoding of a substitution. This substitution can
  be applied to an expression. For instance we will write $\tau[\theta]$ as
  substitution for base types and similar for other construction. As an example
  we have
  $(\langle \alpha_1, \alpha_2 \rangle)[\mathtt{int} / \alpha_1] = \langle
  \mathtt{int}, \alpha_2 \rangle$.
\item Sometimes it is useful to run more than one instantiation. The syntactic
  category \emph{instantiations} is used for this. We will write $\tau[\Theta]$
  for running multiple substitutions.  For instance
  $(\langle \alpha_1, \alpha_2 \rangle)[\mathtt{int} / \alpha_1 :: \mathtt{uninit} /
  \alpha_2 :: \nil] = \langle \mathtt{int}, \mathtt{uninit} \rangle$.
\end{itemize}

The other differences are:

\begin{itemize}
\item The global values and heap values have had a type added to them. This is
  mostly used to allow decidable type-checking, as nothing will depend on these
  values at run-time. The $\Delta$ in the definition of global values is a
  binder which allows parametric polymorphism.
\item The \texttt{malloc} instruction have been changed to include the type of
  the allocated tuple.
\item Instantiations have been added to word values and small values. This is
  used to instantiate and weaken the parametric polymorphism of code
  pointers. To give an example, assume that $\high w$ is a small-value referring
  to some basic block with the polymorphic parameters $\Delta$. In that case
  $\Lambda\ \Delta' \cdot \high{w}[\Theta]$ refers to a basic block with
  polymorphic parameters $\Delta'$. This basic block is the result of using
  $\Theta$ to instantiate $\Delta$. Here $\Theta$ is allowed to use $\Delta'$ in
  its instantiation.
\end{itemize}

\begin{figure}
  {\footnotesize
    \begin{tabular}{lrcl}
      Variables: \\
      \textit{global pointers} & $\ell_{\mathrm{g}}$ \\
      \textit{heap pointers}   & $\ell_{\mathrm{h}}$ \\
      \textit{type variable}   & $\alpha$ \\
      \textit{stack variable}  & $\rho$ \\\\

      Common definitions: \\
      \textit{integer}            & $n$ & ::= & $0, 1, \dots$ \\
      \textit{machine integers}   & $i$ & ::= & $0, 1, \dots, 2^{\mathrm{wordsize}}-1$ \\
      \textit{registers}          & $r$ & ::= & $\mathtt{r}_1 \mid \dots \mid \mathtt{r}_{\mathrm{max}}$ \\\\

      The type system for \ATAL: \\
      \textit{base types}               & $\tau$ & ::= & $\alpha \mid \mathtt{int} \mid \mathtt{uninit} \mid \mathtt\forall[ \Delta ] \Gamma \mid \langle\tau^\phi,\dots,\tau^\phi\rangle$ \\
      \textit{initialization flags}     & $\phi$ & ::= & $\mathtt{init} \mid \mathtt{uninit}$ \\
      \textit{stack types}              & $\sigma$ & ::= & $\rho \mid \nil \mid \tau :: \sigma$ \\
      \textit{type assignments}         & $\Delta$ & ::= & $\nil \mid a :: \Delta$ \\
      \textit{type assignment value}    & $a$ & ::= & $\alpha \mid \rho$ \\
      \textit{global label assignments} & $\Psi_{\mathrm{g}}$ & ::= & $\{\ell_{\mathrm{g}} |-> \tau, \dots, \ell_{\mathrm{g}} |-> \tau\}$ \\
      \textit{heap label assignmentss}  & $\Psi_{\mathrm{h}}$ & ::= & $\{\ell_{\mathrm{h}} |-> \tau, \dots, \ell_{\mathrm{h}} |-> \tau\}$ \\
      \textit{register assignments}     & $\Gamma$ & ::= & $\{\mathtt{sp} |-> \sigma, \mathtt{r}_1 |-> \tau, \dots, \mathtt{r}_{\mathrm{max}} |-> \tau\}$ \\
      \textit{instantiation}            & $\theta$ & ::= & $\tau/\alpha \mid \sigma/\rho$ \\
      \textit{instantiations}           & $\Theta$ & ::= & $\theta :: \Theta \mid \nil$ \\\\

      The syntax for \ATAL itself: \\
      \textit{word values}              & $\high w$ & ::= & $\mathtt{int}\ i \mid \mathtt{globval}\ \ell_{\mathrm{g}} \mid \Lambda\ \Delta \cdot \high{w}[\Theta] \mid \mathtt{heapval}\ \ell_{\mathrm{h}} \mid \mathtt{uninit}$ \\
      \textit{small values}             & $\high v$ & ::= & $\mathtt{int}\ i \mid \mathtt{globval}\ \ell_{\mathrm{g}} \mid \Lambda\ \Delta \cdot \high{v}[\Theta] \mid \mathtt{reg}\ r$ \\
      \textit{global values}            & $\high g$ & ::= & $\mathtt{code}[ \Delta ] \Gamma \cdot \high I$ \\
      \textit{heap values}              & $\high h$ & ::= & $\mathtt{tuple}\ \langle \tau, \dots, \tau \rangle\ \langle \high w, \dots, \high w \rangle$ \\
      \textit{stacks}                   & $\high S$ & ::= & $\nil \mid \high w :: \high S$ \\
      \textit{instructions} & $\high\iota$ & ::= & $\mathtt{add}\ r, r, \high v \mid \mathtt{sub}\ r, r, \high v \mid$ \\
                               &&& $\mathtt{salloc}\ n \mid \mathtt{sfree}\ n \mid$ \\
                               &&& $\mathtt{ld}\ r, \mathtt{sp}(n) \mid \mathtt{ld}\ r, r(n) \mid$ \\
                               &&& $\mathtt{st}\ \mathtt{sp}(n), r \mid \mathtt{st}\ r(n), r \mid$ \\
                               &&& $\mathtt{malloc}\ r,\ \langle \tau, \dots, \tau \rangle \mid $ \\
                               &&& $\mathtt{mov}\ r, \high v \mid \mathtt{beq}\ r, \high v$ \\
      \textit{instruction sequences} & $\high I$ & ::= & $\high\iota ; \high I \mid \mathtt{jmp}\ \high v \mid \mathtt{halt}$ \\\\

      \textit{global collections}       & $\high G$ & ::= & $\{\ell_{\mathrm{g}} |-> \high{g}, \dots, \ell_{\mathrm{g}} |-> \high{g}\}$ \\
      \textit{heap collections}         & $\high H$ & ::= & $\{\ell_{\mathrm{h}} |-> \high{h}, \dots, \ell_{\mathrm{h}} |-> \high{h}\}$ \\
      \textit{register files}           & $\high R$ & ::= & $\{\mathtt{sp} |-> \high{S}, \mathtt{r}_1 |-> \high{w}, \dots, \mathtt{r}_{\mathrm{max}} |-> \high{w}\}$ \\
      \textit{program states} & $\high P$ & ::= & $(\high G, \high H, \high R, \high I)$ \\
    \end{tabular}
  }
  \caption{The syntax for \ATAL}
  \label{fig:syntax}
\end{figure}

\subsection{Notes on the Agda implementation}

Our Agda-version of this syntax is implemented in the
\texttt{Judgments/HighSyntax.agda}, which is very close to the above
presentation. Additionally the file \texttt{Judgments/Substitution.agda}
contains definitions of substitution and weakening.

Our handling of $\ell_{\mathrm{g}}, \ell_{\mathrm{h}}$, registers and
dictionaries is completely equivalent to what we did in \ATALe. The newly
introduced variables $\alpha$ and $\rho$ are used for name-binding instead of
looking up values in dictionaries. We are still using natural numbers though, in
this case as a way to implement De Bruijn indices.

The fact that we are using De Bruijn indices for variables in different
syntactic categories turns out to be slightly problematic. In our paper notation
a substitution is always well-defined, however in our Agda-code we might use a
particular De Bruijn index wrong. This implies that substitution is not a total
function in our Agda code -- a substitution might fail if referring to a $\rho$
where an $\alpha$ is needed.

For this reason, we have chosen to implement substitution as a relation, which
we will prove to be a partial, computable function. We also need to implement
weakening explicitly, which we do using a regular (total) function. These are
the type declarations from the file \texttt{Judgments/Substitution.agda}, where
$A$ is one of the datatypes for which substitution is valid:

\begin{code}
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{weaken} \AgdaSymbol{:} \AgdaDatatype{ℕ} \AgdaSymbol{→} \AgdaDatatype{ℕ} \AgdaSymbol{→} \AgdaBound{A} \AgdaSymbol{→} \AgdaBound{A}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{\_⟦\_/\_⟧≡\_} \AgdaSymbol{:} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Instantiation} \AgdaSymbol{→} \AgdaDatatype{ℕ} \AgdaSymbol{→} \AgdaBound{A} \AgdaSymbol{→} \AgdaPrimitiveType{Set}\<%
\end{code}

\subsection{Lemmas}

The file \texttt{Lemmas/Equality.agda} contains proofs for decidable equality
using the same method as for \ATALe. Additionally the file
\texttt{Lemmas/Substitution.agda} holds some lemmas about substitution such as:

\begin{lemma}
  \label{lemma:computsubst}
  Substitution is a partial, computable function. More specifically:
  \begin{itemize}
  \item If $\tau[\theta]$ evaluates to both $\tau_1$ and $\tau_2$, then
    $\tau_1 = \tau_2$.
  \item It is decidable to check if $\tau[\theta]$ is well-defined.
  \end{itemize}

  Similar statements hold for the other syntactic categories.
\end{lemma}

These proofs are in principle trivial, and proved by simple structural induction
over the arguments for the substitutions. In practice this involved a few tricky
cases and a lot of boilerplate.

The file additionally contains lemmas about the commutativity of substitutions
and weakenings. A very informal version of this lemma is as follows:

\begin{lemma}
  Assume we have $\tau_1[\theta] = \tau_2$. This equation still holds if we
  weaken $\tau_1, \tau_2$ and $\theta$. The weakening done on each part is not
  exactly the same, but they are related. A similar statement holds if we
  instead of weakening run another substitution $\theta'$. This substitution
  will again not be the exact same for each part, but the substitutions are
  related.

  Similar statements hold for the other syntactic categories.
\end{lemma}

This statement is hard to state precisely, as it depends heavily on the details
of our De Bruijn indices, which we have left out in this paper. A more precise
definition of the lemma along with the proofs are available in the source
code\footnote{Specifically see the functions \texttt{weaken-subst} and
  \texttt{subst-subst} in \texttt{Lemmas/Substitution.agda}}.

The proofs themselves are for the most part done using structural induction. The
only non-trivial cases are those dealing directly with De Bruijn notation -- but
some of those require several sub-lemmas.

\section{Semantics for \ATAL}

This brings us to the semantics for \ATAL. There are a few different judgments
used:

\begin{tabular}{|c|p{7.5 cm}|}
  \hline
  Judgment & \multicolumn{1}{|c|}{Meaning} \\\hline
  $\evalregs{\high R}{\high v}{\high w}$ & Here $\high v$ is a small value, that is used an argument to an instruction. This judgment states that we can evaluate $v$ to $\high w$ by looking up registers in the register file $\high R$. \\\hline
  $\evalcode{\high G}{\high w}{\high I}$ & Here $\high w$ is a word value that we intend to jump to. This judgment states that we can evaluate $\high w$ to the basic block $\high I$ by looking up basic blocks in $\high G$ and possibly instantiating some of the type variables. \\\hline
  $\execis{\high G}{\high H, \high R, \high I}{\high H', \high R', \high I'}$ & This is our main small-step relation. It is a judgment that asserts that if a program is in state $(\high G, \high H, \high R, \high I)$, then it can transition to $(\high G, \high H', \high R', \high I')$. Note that $G$ is immutable. \\\hline
  $\steps{\high P}{\high P'}$ & This states that the program state $\high P$ can small-step to $\high P'$. It has only a single rule which uses the judgment above. \\\hline
  $\stepsn{\high P}{n}{\high P'}$ & This states that the program state $\high P$' can small-step to $\high P'$ in $n$ steps. \\\hline
\end{tabular} \\

Let us start with the last two judgments as they are the simplest: \\

\fbox{$\steps{\high P}{\high P'}$}
\begin{mathpar}
  \infer{
    \execis{\high G}{(\high H, \high R, \high I)}{(\high H', \high R', \high I')}
  }{
    \steps{(\high G, \high H, \high R, \high I)}{(\high G, \high H', \high R', \high I')}
  }
\end{mathpar}

\fbox{$\stepsn{\high P}{n}{\high P'}$}
\begin{mathpar}
  \infer{
  }{
    \stepsn{\high P}{0}{\high P}
  } \and
  \infer{
    \steps{\high P}{}{\high P'} \and
    \stepsn{\high P'}{n}{\high P''}
  }{
    \stepsn{\high P}{1+n}{\high P''}
  }
\end{mathpar}

The definition for $\evalregs{\high R}{\high v}{\high w}$ is also pretty simple
-- it simply replaces \texttt{reg}-values by looking up the register in the
register file: \\

\fbox{$\evalregs{\high R}{\high v}{\high w}$}
\begin{mathpar}
  \infer{
  }{
    \evalregs{\high R}{\mathtt{reg}\ r}{\high R[r]}
  } \and
  \infer{
  }{
    \evalregs{\high R}{\mathtt{globval}\ \ell_{\mathrm{g}}}{\mathtt{globval}\ \ell_{\mathrm{g}}}
  } \and
  \infer{
  }{
    \evalregs{\high R}{\mathtt{int}\ i}{\mathtt{int}\ i}
  } \and
  \infer{
    \evalregs{\high R}{\high v}{\high w}
  }{
    \evalregs{\high R}{\Lambda\ \Delta \cdot \high{v}[\Theta]}{\Lambda\ \Delta \cdot \high{w}[\Theta]}
  }
\end{mathpar}

\todo{More text}

\fbox{$\evalcode{\high G}{\high w}{I}$}
\begin{mathpar}
\infer{
  \high G[\ell_{\mathrm{g}}] = \mathtt{code}[ \Delta ] \Gamma \cdot \high I
}{
  \evalcode{\high G}{\mathtt{globval}\ \ell_{\mathrm{g}}}{\high I}
} \and
\infer{
  \evalcode{\high G}{w}{\high I} \and
  \high I' = \high I[\Theta]
}{
  \evalcode{\high G}{\Lambda\ \Delta \cdot \high w[\Theta]}{\high I'}
}
\end{mathpar}

\todo{More text}

\fbox{$\execis{\high G}{\high H, \high R, \high I}{\high H', \high R', \high I'}$}
\begin{mathpar}
\infer{
  \high R[r_b] = \mathtt{int}\ i_1 \and
  \evalregs{\high R}{\high v}{\mathtt{int}\ i_2}
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{add}\ r_a, r_b, \high v) ; \high I}
    {\high H, \high R[r_a \mapsto \mathtt{int}\ (i_1 + i_2)], \high I}
} \and
\infer{
  \high R[r_b] = \mathtt{int}\ i_1 \and
  \evalregs{\high R}{\high v}{\mathtt{int}\ i_2}
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{sub}\ r_a, r_b, \high v) ; \high I}
    {\high H, \high R[r_1 \mapsto \mathtt{int}\ (i_1 - i_2)], \high I}
} \and
\infer{
  \high S = \overbrace{\mathtt{uninit} :: \dots :: \mathtt{uninit}}^n :: \high R[\mathtt{sp}]
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{salloc}\ n) ; \high I}
    {\high H, \high R[\mathtt{sp} |-> \high S], \high I}
} \and
\infer{
  \high R[\mathtt{sp}] = \overbrace{\high w_1 :: \dots :: \high w_n}^n :: \high S
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{sfree}\ n) ; \high I}
    {\high H, \high R[\mathtt{sp} |-> \high S], \high I}
} \and
\infer{
  \high R[\mathtt{sp}][n] = \high w
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{ld}\ r, \mathtt{sp}(n)) ; \high I}
    {\high H, \high R[r |-> \high w], \high I}
} \and
\infer{
  \high R[r_b] = \mathtt{heapval}\ \ell_{\mathrm{h}} \and
  \high H[\ell_{\mathrm{h}}] = \mathtt{tuple}\ \langle \tau_1, \dots \rangle\ \langle \high w_1, \dots, \high w_n, \dots \rangle
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{ld}\ r_a, r_b(n)) ; \high I}
    {\high H, \high R[r_a |-> \high w_n], \high I}
} \and
\infer{
  R[r] = \high w \and
  R[\mathtt{sp}] = \high S
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{st}\ \mathtt{sp}(n), r) ; \high I}
    {\high H, \high R[\mathtt{sp} |-> \high S[n |-> \high w]], \high I}
} \and
\infer{
  \high R[r_a] = \mathtt{heapval}\ \ell_{\mathrm{h}} \and
  \high H[\ell_{\mathrm{h}}] = \mathtt{tuple}\ \langle \tau_1, \dots \rangle\ \langle \high w_1, \dots \high w_n, \dots \rangle \and
  \high R[r_b] = \high w \and
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{st}\ r_a(n), r_b) ; \high I}
    {\high H[\ell_{\mathrm{h}} |-> \mathtt{tuple}\ \langle \tau_1, \dots, \rangle\ \langle \high w_1, \dots, w, \dots \rangle], \high R, \high I}
} \and
\infer{
  \ell_{\mathrm{h}} \notin \mathbf{dom}(\high H) \and
  \high h = \mathtt{tuple}\ \langle \tau_1, \dots, \tau_n \rangle\ \overbrace{\langle \mathtt{uninit}, \dots, \mathtt{uninit} \rangle}^n
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{malloc}\ r, \langle \tau_1, \dots, \tau_n \rangle) ; \high I}
    {\high H \cup \{\ell_{\mathrm{h}} |-> \high h\}, R[r |-> \mathtt{heapval}\ \ell_{\mathrm{h}}], \high I}
} \and
\infer{
  \evalregs{\high R}{\high v}{\high w}
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{mov}\ r, \high v) ; \high I}
    {\high H, \high R[r |-> \high w], \high I}
} \and
\infer{
  \high R[r] = \mathtt{int}\ 0 \and
  \evalregs{\high R}{\high v}{\high w} \and
  \evalcode{\high G}{\high w}{I'}
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{beq}\ r, \high v) ; \high I}
    {\high H, \high R, \high I'}
} \and
\infer{
  \high R[r] = \mathtt{int}\ i \and
  i \neq 0
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{beq}\ r, \high v) ; \high I}
    {\high H, \high R, \high I}
} \and
\infer{
  \evalregs{\high R}{\high v}{\high w} \and
  \evalcode{\high G}{\high w}{I}
}{
  \execis{\high G}
    {\high H, \high R, \mathtt{jmp}\ \high v}
    {\high H, \high R, \high I}
}
\end{mathpar}

\subsection{Notes on the Agda implementation}

The file \texttt{Judgments/HighSemantics.agda} is very close in form to this
presentation. We have deviated slightly from this form, as the Agda-version uses
functions for some syntax where the thesis uses premises and vice versa.

\subsection{Lemmas}

It turns out that our small-semantics is deterministic, which implies that it is
a partial function, so the following lemma is proved in the file
\texttt{Lemmas/HighSemantics.agda}.

\begin{lemma}
  \label{lemma:computhigh}
  Our small-step relation for \ATAL is a partial, computable function. Or more
  precisely:

  \begin{itemize}
  \item If $\high P, \high P', \high P''$ are a program states and we have both
    $\steps{\high P}{\high P'}$ and $\steps{\high P}{\high P''}$, then
    $\high{P'} = \high{P''}$.
  \item It is decidable whether $\high P$ can small-step to some $\high P'$.
  \end{itemize}

  Similar lemmas exists for the other semantic judgments.
\end{lemma}

\section{Semantics for \ATALe}

The semantics for \ATALe er mostly the same as for \ATAL -- it has the same 5
core judgments as. The difference are:

\begin{itemize}
\item $\evalregs{\simple R}{\simple v}{\simple w}$ has one case less than
  $\evalregs{\high R}{\high v}{\high w}$ because \ATALe does not have the
  instantiation syntax.
\item For the same reason there is one fewer case for
  $\evalcode{\simple G}{\simple w}{\simple I}$. Note that this makes the
  judgment mostly trivial.
\item
  $\execis{\simple G}{\simple H, \simple R, \simple I}{\simple H', \simple R',
    \simple I'}$ has changed slightly. The cases for $\mathtt{ld}\ r_a, r_b(n)$
  and $\mathtt{st}\ r_a(n), r_b$ have been simplified in the obvious way as
  tuples no longer carry type information. The case for $\mathtt{malloc}$ is the
  only one that has a non-trivial change:
\end{itemize}

\begin{mathpar}
\infer{
  \ell_{\mathrm{h}} \notin \mathbf{dom}(\simple H) \and
  \simple h = \mathtt{tuple}\ \overbrace{\langle \mathtt{uninit}, \dots, \mathtt{uninit} \rangle}^n
}{
  \execis{\simple G}
    {\simple H, \simple R, (\mathtt{malloc}\ r, n) ; \simple I}
    {\simple H \cup \{\ell_{\mathrm{h}} |-> \simple h\}, R[r |-> \mathtt{heapval}\ \ell_{\mathrm{h}}], \simple I}
} \and
\end{mathpar}

The full semantics for \ATALe have been included in the appendix.\todo{Where in
  the appendix?}

\subsection{Notes on the Agda implementation}

The file \texttt{Judgments/SimpleSemantics.agda} is again very close in form to
this presentation. We have made the same deviations as we did for \ATAL.

\subsection{Lemmas}

It should be no surprise that this small-step semantics is deterministic, given
that it is mostly the same as for \ATAL. We prove the following lemma in
\texttt{Lemmas/SimpleSemantics.agda}:

\begin{lemma}
  \label{lemma:computsimple}
  Our small-step relation for \ATALe is a partial, computable function. Or more
  precisely:

  \begin{itemize}
  \item If $\simple P, \simple{P'}, \simple{P''}$ are a program states and we
    have both $\steps{\simple P}{\simple{P'}}$ and
    $\steps{\simple P}{\simple{P''}}$, then $\simple{P'} = \simple{P''}$.
  \item It is decidable whether $\simple P$ can small-step to some $\simple{P'}$.
  \end{itemize}

  Similar lemmas exists for the other semantic judgments.
\end{lemma}
