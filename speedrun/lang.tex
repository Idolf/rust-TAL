\chapter{\ATAL and \ATALe}
\label{chap:lang}

As stated \cref{sec:goal}, we want to design a secure sandbox, and to do so we
will need to design a Typed Assembly Language and prove soundness for it. In
this chapter we will introduce the two languages in which we will build this
sandbox. We will do this by:

\begin{itemize}
\item Defining \ATAL and \ATALe in terms of their program states.
\item The set of possible program states are defined in terms a Context-Free
  Grammar in our Agda formalization. In our paper definition, we have chosen to
  use some syntax that is not Context-Free for increased readability. As we
  shall see, this is not a problem as there is a trivial correspondence between
  the two presentations.
\item We will present a small-step semantics for the two languages and prove
  that they are related by the erasure property.
\end{itemize}

The full implications of and reasoning behind having two languages related by
erasure will be discussed later. \Cref{chap:erasure} will discuss some of the
issues along with the proof, while the full reasoning will not be apparent until
\Cref{chap:safesound}. For now let us just state these two unbacked postulates
over the alternative of using a single language:

\begin{itemize}
\item By having two languages we are mostly able to separate our type system
  from our model simplification. This is advantageous for instance when
  reasoning about the sandbox implementation.
\item This separation also allows one to experiment with different type systems:
  As long as the type system is sound, decidable and has the erasure property,
  then it should be able to use the same sandbox infrastructure.
\end{itemize}

Before formally defining the languages, we will give an informal understanding
of our model by comparing it to real-world CPUs.

\section{Architecture and Evaluation Model}

Most real-world CPUs use some kind of a von Neumann architecture. In its
simplest form, you only need memory and registers each holding some number of
machine words along with a procedure to fetch an instruction from memory, decode
and execute it. This executing (optionally) changes the memory and registers,
after which the process is repeated. We will refer to this model as the
real-world model; even though many modern CPU-architectures are more complicated
than this, the difference are for the most part not relevant to this discussion.

In the real-world model there are only two conceptual abstractions: Machine
words are fixed-width integers and instructions are just decoded machine
words. This simplicity makes it easier to implement and analyze CPU designs,
however it makes hard to analyze programs for the platform.

To support effective program analysis, both \ATAL and \ATALe deviates from this
model in a number of ways. As \ATALe deviates the least, we will start by
introducing it.

\subsection{Difference between \ATALe and the real-world model}

In the real-world model machine words are simply fixed-size integers and these
are used for multiple purposes. In \ATALe every machine word have been
statically tagged with their intended usage. This tag is only relevant in our
model and it not present in the real-world. While any machine word can still be
copied or overwritten additional operations are only defined for some tags:

\begin{itemize}
\item Words tagged as numbers can be used for arithmetics.
\item Words tagged as pointers can only be used to dereference memory. Depending
  on the pointer, this dereference could be a read or a write.
\item Words tagged as uninitialized does not have any additional operations.
\end{itemize}

Another difference is that instructions are no longer decoded machine
words. Instead they are collected into pre-decoded basic blocks. A basic block
is an immutable series of instructions that ends with an unconditional jump or a
halt instruction.

Memory is no longer a continuous array of machine words. Instead it has been
split into three parts each with difference functions:

\begin{itemize}
\item The global values/globals is where code is stored. It is a collection of
  basic blocks. The only operation supported by the global values is to fetch a
  specific basic block.
\item The heap is where long-lived mutable data lives. It is a collection of
  tuples, where each tuple is a collection of machine words. It supports three
  operations: allocating a new tuple of a given size along with reading/write a
  machine word given a pointer to a tuple and a tuple-index. It does not support
  deallocating tuples. This is an unfortunate part of our model, and we will in
  \Cref{chap:safesound} discuss this problem including how to partially mitigate
  it by using garbage collection.
\item The stack is where short-lived mutable data lives. It is a collection of
  machine words. It supports four operations: Adding a number of uninitialized
  machine words to the top of the stack, deallocating a number of machine words
  (no matter their tag) from the top of the stack, reading or writing a machine
  words indexes by distance from the top of the stack.
\end{itemize}

The registers are still a collection of machine words with the exception of the
special-purpose register \texttt{sp}. This register is no longer a machine word,
but instead always points to the top of the stack.

In addition to splitting memory, we will also restrict the possible values a
pointer can take. A pointer can only point to the beginning of a heap-tuple or
to the beginning of a basic block\footnote{On the surface this seems to disallow
  some cases of code re-use, however it turns out to not be so much of a problem
  in practice. If we wanted to refer to some point in the middle of a basic
  block, then we could simply split it and insert an unconditional jump at the
  end of the first block. We might even make this jump implicit to avoid wasting
  space.}. Machine words cannot point to the stack; the only reference to the
stack is \texttt{sp}.

Finally the issue of memory organization have been abstracted away. It is no
longer meaningful to talk about the ``location'' of values in memory. As an
example the stack is neither below nor above the heap, it simply \emph{is}.  An
indirect consequence of this is also that memory is effectively infinite in our
model. This has some interesting consequences for the relation to the real-world
model which we will discuss in \Cref{chap:safesound}. Until then we will ignore
the issue by staying inside our models.

\subsection{Additional differences introduced by \ATAL}

The \ATAL model goes a step further by introducing a type system, which is used
during the run-time. The fundamental concept is that of a \emph{type}. Some
informal examples of types are ``integer'', ``basic block taking an integer as
argument'' or ``tuple of two integers''. This type system includes the
parametric polymorphism and subtyping. The only types that are allowed to be
polymorphic is the types of basic blocks.

In \ATAL all basic blocks and tuples have a type associated with them. This
associated type is superficially similar to the tag added to machine words. The
biggest difference is that the tags for machine words matter at run-time, while
the associated types do not.

Another change with \ATAL is that places where one could refer to a basic block
(such as inside an instruction or word value), one can now \emph{additionally}
add generalization and instantiation information to the value.

\section{Grammar for \ATALe}

Before introducing \ATAL, let us introduce \ATALe, as it is simpler and better
captures the intended meaning of the language. The language itself is a set of
states. In the Agda-implementation uses a context-free grammar for this, though
the version presented here is strictly speaking not context free, as it uses
dictionaries.

{\footnotesize
\begin{tabular}{lrcl}
Variables: \\
\textit{global pointers} & $\ell_{\mathrm{g}}$ \\
\textit{heap pointers}   & $\ell_{\mathrm{h}}$ \\\\

Common definitions: \\
\textit{integer}            & $n,k$ & ::= & $0, 1, \dots$ \\
\textit{machine integers}   & $i$   & ::= & $0, 1, \dots, 2^{\mathrm{wordsize}}-1$ \\
\textit{registers}          & $r$   & ::= & $\mathtt{r}_1 \mid \dots \mid \mathtt{r}_{\mathrm{max}}$ \\\\

The grammar for \ATALe: \\
\textit{word values}        & $\simple w$ & ::= & $\mathtt{globval}\ \ell_{\mathrm{g}} \mid \mathtt{heapval}\ \ell_{\mathrm{h}} \mid \mathtt{int}\ i \mid \mathtt{uninit}$ \\
\textit{small values}       & $\simple v$ & ::= & $\mathtt{globval}\ \ell_{\mathrm{g}} \mid \mathtt{reg}\ r \mid \mathtt{int}\ i$ \\
\textit{global values}      & $\simple g$ & ::= & $\mathtt{code}\ \simple I$ \\
\textit{global collections} & $\simple G$ & ::= & $\{\ell_{\mathrm{g}} |-> \simple{g}, \dots, \ell_{\mathrm{g}} |-> \simple{g}\}$ \\
\textit{heap values}        & $\simple h$ & ::= & $\mathtt{tuple}\ \langle \simple w, \dots, \simple w \rangle$ \\
\textit{heap collections}   & $\simple H$ & ::= & $\{\ell_{\mathrm{h}} |-> \simple{h}, \dots, \ell_{\mathrm{h}} |-> \simple{h}\}$ \\
\textit{stacks}             & $\simple S$ & ::= & $\nil \mid \simple w :: \simple S$ \\
\textit{register files}     & $\simple R$ & ::= & $\{\mathtt{sp} |-> \simple{S}, \mathtt{r}_1 |-> \simple{w}, \dots, \mathtt{r}_{\mathrm{max}} |-> \simple{w}\}$ \\\\

\textit{instructions} & $\simple \iota$ & ::= & $\mathtt{add}\ r, r, \simple v \mid \mathtt{sub}\ r, r, \simple v \mid$ \\
        &&& $\mathtt{salloc}\ n \mid \mathtt{sfree}\ n \mid$ \\
        &&& $\mathtt{ld}\ r, \mathtt{sp}(n) \mid \mathtt{ld}\ r, r(n) \mid$ \\
        &&& $\mathtt{st}\ \mathtt{sp}(n), r \mid \mathtt{st}\ r(n), r \mid$ \\
        &&& $\mathtt{malloc}\ r,\ n \mid $ \\
        &&& $\mathtt{mov}\ r, \simple v \mid \mathtt{beq}\ r, \simple v$ \\
\textit{instruction sequences} & $\simple I$ & ::= & $\simple\iota ; \simple I \mid \mathtt{jmp}\ \simple v \mid \mathtt{halt}$ \\
\textit{program states} & $\simple P$ & ::= & $(\simple G, \simple H, \simple R, \simple I)$ \\\\
\end{tabular}
}

This definition follows fairly close to the information version we have already
presented. The only new construction is that of a ``small value''. A small value
is an argument to some instruction such as \texttt{add}. It allows one to write
an immediate in the form of a reference to a basic block or
number. Alternatively it allows one to specify a register which will be looked
up at run-time. It does \emph{not} allow one to write heap values, as the exact
value of heap values are not known at compile-time.

Another interesting detail is the inclusion of a \texttt{malloc} instruction,
which is typically not present in a real-world machine. This instruction is to
be interpreted as a small group of instructions that always occurs together. On
the real machine, this instruction would likely include branch to a subroutine
in the TCB where malloc is implemented.

\subsection{Notes on the Agda implementation}

There is only one major difference between this version and the one in
\texttt{Judgments/SimpleGrammar.agda}, and that is the issue of the dictionaries
and variables. In the presented version we simply assumed an infinite number of
variables
$\ell_{\mathrm{g},0}, \ell_{\mathrm{h},0}, \ell_{\mathrm{g},1}, \dots$, and
created dictionaries using these variables as keys.

This approach is not suitable in the Agda-version, as the Agda-version uses a
context-free grammar. Instead we will assign these abstract variables to natural
numbers. This means that we can use ordered lists instead of dictionaries, and
ordered lists can be represented using a context-free grammar.

For instance: The globals collection
$\{\ell_{\mathrm{g},0} |-> g_{\mathrm{e},0}, \ell_{\mathrm{g},1} |->
h_{\mathrm{e},1}\}$ could be represented in the Agda-code by the list
$h_{\mathrm{e},0} :: h_{\mathrm{e},1} :: \mathtt{nil}$ in which case we would
have $\ell_{\mathrm{g},0} = 0, \ell_{\mathrm{g},1} = 1$. The other valid choice
would be $h_{\mathrm{e},1} :: h_{\mathrm{e},0} :: \mathtt{nil}$, but in this
case we must have $\ell_{\mathrm{g},0} = 1, \ell_{\mathrm{g},1} = 0$.

\subsection{Lemmas}

At this point, we are already able to prove lemmas about our grammar. In the
file \texttt{Lemmas/Equality.agda} we prove this and similar lemmas:

\begin{lemma} Given two program states $\simple{P}, \simple{P'}$ we can decide
  whether we have $\simple P = \simple{P'}$ or $\simple P \neq \simple{P'}$.
\end{lemma}

This lemma might seem trivial, and in a certain sense it is: It holds for all
inductive data types. One could in principle just prove this by induction over
the forms of $\simple P$ and $\simple{P'}$, however this turns out to give a
quadratic number of cases in Agda. Our solution to this problem is to use an
injective function to another data type. See \cref{sec:deceq} for more details.

\section{Grammar for \ATAL}

The grammar for \ATAL is very similar. There are very few syntactic
differences (besides the addition of the type system itself):

\begin{itemize}
\item Global values have had a type added to them. This type is only added as
  hint to the type-checker -- it is not actually used at run-time. This type is
  added to specify which generics a basic block supports.
\item Heap values have had a type added to them as well. These types only have
  relevance for the \texttt{malloc} instruction -- and even then they do not
  affect any other aspects of the run-time.
\item Instantiations have been added to word values and small values. This
  syntax is used to instantiate the type variables of a basic block.
\item The \texttt{malloc} instruction no longer takes a number as the second
  argument. Instead it takes a list of types.
\end{itemize}

{\footnotesize
\begin{tabular}{lrcl}
Variables: \\
\textit{global pointers} & $\ell_{\mathrm{g}}$ \\
\textit{heap pointers}   & $\ell_{\mathrm{h}}$ \\
\textit{type variable}   & $\alpha$ \\
\textit{stack variable}  & $\rho$ \\\\

Common definitions: \\
\textit{integer}            & $n,k$ & ::= & $0, 1, \dots$ \\
\textit{machine integers}   & $i$   & ::= & $0, 1, \dots, 2^{\mathrm{wordsize}}-1$ \\
\textit{registers}          & $r$   & ::= & $\mathtt{r}_1 \mid \dots \mid \mathtt{r}_{\mathrm{max}}$ \\\\

The type system for \ATAL: \\
\textit{base types}               & $\tau$ & ::= & $\alpha \mid \mathtt{int} \mid \mathtt{ns} \mid \mathtt\forall[ \Delta ] \Gamma \mid \langle\tau^\phi,\dots,\tau^\phi\rangle$ \\
\textit{initialization flags}     & $\phi$ & ::= & $\mathtt{init} \mid \mathtt{uninit}$ \\
\textit{stack types}              & $\sigma$ & ::= & $\rho \mid \nil \mid \tau :: \sigma$ \\
\textit{type assignments}         & $\Delta$ & ::= & $\nil \mid a :: \Delta$ \\
\textit{type assignment value}    & $a$ & ::= & $\alpha \mid \rho$ \\
\textit{global label assignments} & $\Psi_{\mathrm{g}}$ & ::= & $\{\ell_{\mathrm{g}} |-> \tau, \dots, \ell_{\mathrm{g}} |-> \tau\}$ \\
\textit{heap label assignmentss}  & $\Psi_{\mathrm{h}}$ & ::= & $\{\ell_{\mathrm{h}} |-> \tau, \dots, \ell_{\mathrm{h}} |-> \tau\}$ \\
\textit{register assignments}     & $\Gamma$ & ::= & $\{\mathtt{sp} |-> \sigma, \mathtt{r}_1 |-> \tau, \dots, \mathtt{r}_{\mathrm{max}} |-> \tau\}$ \\
\textit{instantiation}            & $\theta$ & ::= & $\tau/\alpha \mid \sigma/\rho$ \\
\textit{instantiations}           & $\Theta$ & ::= & $\theta :: \Theta \mid \nil$ \\\\

The grammar for \ATAL itself: \\
\textit{word values}              & $\high w$ & ::= & $\mathtt{globval}\ \ell_{\mathrm{g}} \mid \mathtt{heapval}\ \ell_{\mathrm{h}} \mid \mathtt{int}\ i \mid \mathtt{uninit} \mid \Lambda\ \Delta \cdot \high{w}[\Theta]$ \\
\textit{small values}             & $\high v$ & ::= & $\mathtt{globval}\ \ell_{\mathrm{g}} \mid \mathtt{reg}\ r \mid \mathtt{int}\ i \mid \Lambda\ \Delta \cdot \high{v}[\Theta]$ \\
\textit{global values}            & $\high g$ & ::= & $\mathtt{code}[ \Delta ] \Gamma \cdot \high I$ \\
\textit{global collections}       & $\high G$ & ::= & $\{\ell_{\mathrm{g}} |-> \high{g}, \dots, \ell_{\mathrm{g}} |-> \high{g}\}$ \\
\textit{heap values}              & $\high h$ & ::= & $\mathtt{tuple}\ \langle \tau, \dots, \tau \rangle\ \langle \high w, \dots, \high w \rangle$ \\
\textit{heap collections}         & $\high H$ & ::= & $\{\ell_{\mathrm{h}} |-> \high{h}, \dots, \ell_{\mathrm{h}} |-> \high{h}\}$ \\
\textit{stacks}                   & $\high S$ & ::= & $\nil \mid \high w :: \high S$ \\
\textit{register files}           & $\high R$ & ::= & $\{\mathtt{sp} |-> \high{S}, \mathtt{r}_1 |-> \high{w}, \dots, \mathtt{r}_{\mathrm{max}} |-> \high{w}\}$ \\\\

\textit{instructions} & $\high\iota$ & ::= & $\mathtt{add}\ r, r, \high v \mid \mathtt{sub}\ r, r, \high v \mid$ \\
        &&& $\mathtt{salloc}\ n \mid \mathtt{sfree}\ n \mid$ \\
        &&& $\mathtt{ld}\ r, \mathtt{sp}(n) \mid \mathtt{ld}\ r, r(n) \mid$ \\
        &&& $\mathtt{st}\ \mathtt{sp}(n), r \mid \mathtt{st}\ r(n), r \mid$ \\
        &&& $\mathtt{malloc}\ r,\ \langle \tau, \dots, \tau \rangle \mid $ \\
        &&& $\mathtt{mov}\ r, \high v \mid \mathtt{beq}\ r, \high v$ \\
\textit{instruction sequences} & $\high I$ & ::= & $\high\iota ; \high I \mid \mathtt{jmp}\ \high v \mid \mathtt{halt}$ \\
\textit{program states} & $\high P$ & ::= & $(\high G, \high H, \high R, \high I)$ \\
\end{tabular}
}

The type system itself is somewhat complicated:

\begin{itemize}
\item The base types are best thought of as the types of word values and small
  values. It also reused for global values and heap values, though these only
  use a subset of the possible types (specifically function types and tuple types).
\item Type assignments are the assumptions used in types. They serve the same
  purpose as generics in Java.
\item Stack types are the type of stacks.
\item Global label assignments are the types of global collections.
\item Heap label assignments are the types of heap collections.
\item Register assignments are the types of register files.
\item An instantiation is an encoding of a substitution. This substitution can
  be applied to an expression. For instance we will write $\tau[\theta]$ as
  substitution for base types and similar for other construction. As an example
  we have
  $(\langle \alpha_1, \alpha_2 \rangle)[\mathtt{int} / \alpha_1] = \langle
  \mathtt{int}, \alpha_2 \rangle$.
\item Instantiations are simply a chain of instantiations. We will write
  $\tau[\Theta]$ for running multiple substitutions.  For instance
  $(\langle \alpha_1, \alpha_2 \rangle)[\mathtt{int} / \alpha_1 :: \mathtt{ns} /
  \alpha_2 :: \nil] = \langle \mathtt{int}, \mathtt{ns} \rangle$.
\end{itemize}

\subsection{Notes on the Agda implementation}

As we did for \ATALe, we will used natural numbers to represent the variables in
\ATAL. In \texttt{Judgments/HighGrammar.agda} we will handle $\ell_{\mathrm{g}}$
and $\ell_{\mathrm{h}}$ using the same technique. The newly introduced variables
$\alpha$ and $\rho$ will be represented using De Bruijn indices. In practice
there is little difference between the two techniques. In both cases we
represent variables using natural numbers and these numbers are used to look up
elements in ordered lists.

The fact that we use De Bruijn indices also means that we need judgments for
substitution and weakening. In fact substitution is not a total relation in our
Agda code -- an expression might be ``wrong'' in the sense that it could use a
De Bruijn index in the wrong way (by referring to a $\rho$ where an $\alpha$ is
needed). It might for instance use a variable-index that refers to an $\alpha$
in the context of a stack-variable, and similarly an instantiation might also be
``wrong''.

As such we have chosen implement to substitution as a relation, which we will
prove is a partial function. Weakening works by simply remapping some of the De
Bruijn indices, and as such it is a total function. These are the type
declarations from the file \texttt{Judgments/Substitution.agda}, where $A$ is
one of the datatypes for which substitution is valid.

\begin{code}
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{weaken} \AgdaSymbol{:} \AgdaDatatype{ℕ} \AgdaSymbol{→} \AgdaDatatype{ℕ} \AgdaSymbol{→} \AgdaBound{A} \AgdaSymbol{→} \AgdaBound{A}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{\_⟦\_/\_⟧≡\_} \AgdaSymbol{:} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Instantiation} \AgdaSymbol{→} \AgdaDatatype{ℕ} \AgdaSymbol{→} \AgdaBound{A} \AgdaSymbol{→} \AgdaPrimitiveType{Set}\<%
\end{code}

\subsection{Lemmas}

The file \texttt{Lemmas/Equality.agda} contains proofs for decidable equality
using the same method as for \ATALe. Additionally the file
\texttt{Lemmas/Substitution.agda} holds some lemmas about substitution such as:

\begin{lemma}
  \label{lemma:computsubst}
  Substitution is a partial, computable function. More specifically:
  \begin{itemize}
  \item If $\tau[\theta]$ evaluates to both $\tau_1$ and $\tau_2$, then
    $\tau_1 = \tau_2$.
  \item It is decidable to check if $\tau[\theta]$ is well-defined.
  \end{itemize}

  Similar statements hold for the other syntactic categories.
\end{lemma}

These proofs are in principle trivial, and proved by simple structural induction
over the arguments for the substitutions. In practice this involved a few tricky
cases and a lot of boilerplate.

The file additionally contains lemmas about the commutativity of substitutions
and weakenings. A very informal version of this lemma is as follows:

\begin{lemma}
  Assume we have $\tau_1[\theta] = \tau_2$. This equation still holds if we
  weaken $\tau_1, \tau_2$ and $\theta$. The weakening done on each part is not
  exactly the same, but they are related. A similar statement holds if we
  instead of weakening run another substitution $\theta'$. This substitution
  will again not be the exact same for each part, but the substitutions are
  related.

  Similar statements hold for the other syntactic categories.
\end{lemma}

This statement is hard to state precisely, as it depends heavily on the details
of our De Bruijn indices, which have been left out in this paper. A more precise
definition of the lemma along with the proofs are available in the source code.

The proofs themselves are for the most part done using structural induction. The
only cases that are suprising are the cases dealing directly with De Bruijn
notation -- but some of those require several sub-lemmas.

\section{Semantics for \ATAL}

This brings us to the semantics for \ATAL. There are a few different judgments
used:

\begin{tabular}{|c|p{7.5 cm}|}
  \hline
  Judgment & \multicolumn{1}{|c|}{Meaning} \\\hline
  $\evalregs{\high R}{\high v}{\high w}$ & Here $\high v$ is a small value, that is used an argument to an instruction. This judgment states that we can evaluate $v$ to $\high w$ by looking up registers in the register file $\high R$. \\\hline
  $\evalcode{\high G}{\high w}{I}$ & Here $\high w$ is a word value that we intend to jump to. This judgment states that we can evaluate $\high w$ to the basic block $\high I$ by looking up basic blocks in $\high G$ and possibly instantiating some of the type variables. \\\hline
  $\execis{\high G}{\high H, \high R, \high I}{\high H', \high R', \high I'}$ & This is our main small-step relation. It is a judgment that asserts that if a program is in state $(\high G, \high H, \high R, \high I)$, then it can transition to $(\high G, \high H', \high R', \high I')$. Note that $G$ is immutable. \\\hline
  $\steps{\high P}{\high P'}$ & This states that the program state $\high P$ can small-step to $\high P'$. It has only a single rule which uses the judgment above. \\\hline
  $\stepsn{\high P}{n}{\high P'}$ & This states that the program state $\high P$' can small-step to $\high P'$ in $n$ steps. \\\hline
\end{tabular} \\

Let us start with the last two judgments as they are the simplest: \\

\fbox{$\steps{\high P}{\high P'}$}
\begin{mathpar}
  \infer{
    \execis{\high G}{(\high H, \high R, \high I)}{(\high H', \high R', \high I')}
  }{
    \steps{(\high G, \high H, \high R, \high I)}{(\high G, \high H', \high R', \high I')}
  }
\end{mathpar}

\fbox{$\stepsn{\high P}{n}{\high P'}$}
\begin{mathpar}
  \infer{
  }{
    \stepsn{\high P}{0}{\high P}
  } \and
  \infer{
    \steps{\high P}{}{\high P'} \and
    \stepsn{\high P'}{n}{\high P''}
  }{
    \stepsn{\high P}{1+n}{\high P''}
  }
\end{mathpar}

The definition for $\evalregs{\high R}{\high v}{\high w}$ is also pretty simple --
it simply replaces \texttt{reg}-values by looking up the register in the
register file: \\

\fbox{$\evalregs{\high R}{\high v}{\high w}$}
\begin{mathpar}
  \infer{
  }{
    \evalregs{\high R}{\mathtt{reg}\ r}{\high R[r]}
  } \and
  \infer{
  }{
    \evalregs{\high R}{\mathtt{globval}\ \ell_{\mathrm{g}}}{\mathtt{globval}\ \ell_{\mathrm{g}}}
  } \and
  \infer{
  }{
    \evalregs{\high R}{\mathtt{int}\ i}{\mathtt{int}\ i}
  } \and
  \infer{
    \evalregs{\high R}{\high v}{\high w}
  }{
    \evalregs{\high R}{\Lambda\ \Delta \cdot \high{v}[\Theta]}{\Lambda\ \Delta \cdot \high{w}[\Theta]}
  }
\end{mathpar}

\fbox{$\evalcode{\high G}{\high w}{I}$}
\begin{mathpar}
\infer{
  \high G[\ell_{\mathrm{g}}] = \mathtt{code}[ \Delta ] \Gamma \cdot \high I
}{
  \evalcode{\high G}{\mathtt{globval}\ \ell_{\mathrm{g}}}{\high I}
} \and
\infer{
  \evalcode{\high G}{w}{\high I} \and
  \high I' = \high I[\Theta]
}{
  \evalcode{\high G}{\Lambda\ \Delta \cdot \high w[\Theta]}{\high I'}
}
\end{mathpar}

\fbox{$\execis{\high G}{\high H, \high R, \high I}{\high H', \high R', \high I'}$}
\begin{mathpar}
\infer{
  \high R[r_b] = \mathtt{int}\ i_1 \and
  \evalregs{\high R}{\high v}{\mathtt{int}\ i_2}
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{add}\ r_a, r_b, \high v) ; \high I}
    {\high H, \high R[r_a \mapsto \mathtt{int}\ (i_1 + i_2)], \high I}
} \and
\infer{
  \high R[r_b] = \mathtt{int}\ i_1 \and
  \evalregs{\high R}{\high v}{\mathtt{int}\ i_2}
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{sub}\ r_a, r_b, \high v) ; \high I}
    {\high H, \high R[r_1 \mapsto \mathtt{int}\ (i_1 - i_2)], \high I}
} \and
\infer{
  \high S = \overbrace{\mathtt{uninit} :: \dots :: \mathtt{uninit}}^n :: \high R[\mathtt{sp}]
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{salloc}\ n) ; \high I}
    {\high H, \high R[\mathtt{sp} |-> \high S], \high I}
} \and
\infer{
  \high R[\mathtt{sp}] = \overbrace{\high w_1 :: \dots :: \high w_n}^n :: \high S
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{sfree}\ n) ; \high I}
    {\high H, \high R[\mathtt{sp} |-> \high S], \high I}
} \and
\infer{
  \high R[\mathtt{sp}][n] = \high w
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{ld}\ r, \mathtt{sp}(n)) ; \high I}
    {\high H, \high R[r |-> \high w], \high I}
} \and
\infer{
  \high R[r_b] = \mathtt{heapval}\ \ell_{\mathrm{h}} \and
  \high H[\ell_{\mathrm{h}}] = \mathtt{tuple}\ \langle \tau_1, \dots \rangle\ \langle \high w_1, \dots, \high w_n, \dots \rangle
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{ld}\ r_a, r_b(n)) ; \high I}
    {\high H, \high R[r_a |-> \high w_n], \high I}
} \and
\infer{
  R[r] = \high w \and
  R[\mathtt{sp}] = \high S
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{st}\ \mathtt{sp}(n), r) ; \high I}
    {\high H, \high R[\mathtt{sp} |-> \high S[n |-> \high w]], \high I}
} \and
\infer{
  \high R[r_a] = \mathtt{heapval}\ \ell_{\mathrm{h}} \and
  \high H[\ell_{\mathrm{h}}] = \mathtt{tuple}\ \langle \tau_1, \dots \rangle\ \langle \high w_1, \dots \high w_n, \dots \rangle \and
  \high R[r_b] = \high w \and
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{st}\ r_a(n), r_b) ; \high I}
    {\high H[\ell_{\mathrm{h}} |-> \mathtt{tuple}\ \langle \tau_1, \dots, \rangle\ \langle \high w_1, \dots, w, \dots \rangle], \high R, \high I}
} \and
\infer{
  \ell_{\mathrm{h}} \notin \mathbf{dom}(\high H) \and
  \high h = \mathtt{tuple}\ \langle \tau_1, \dots, \tau_n \rangle\ \overbrace{\langle \mathtt{uninit}, \dots, \mathtt{uninit} \rangle}^n
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{malloc}\ r, \langle \tau_1, \dots, \tau_n \rangle) ; \high I}
    {\high H \cup \{\ell_{\mathrm{h}} |-> \high h\}, R[r |-> \mathtt{heapval}\ \ell_{\mathrm{h}}], \high I}
} \and
\infer{
  \evalregs{\high R}{\high v}{\high w}
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{mov}\ r, \high v) ; \high I}
    {\high H, \high R[r |-> \high w], \high I}
} \and
\infer{
  \high R[r] = \mathtt{int}\ 0 \and
  \evalregs{\high R}{\high v}{\high w} \and
  \evalcode{\high G}{\high w}{I'}
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{beq}\ r, \high v) ; \high I}
    {\high H, \high R, \high I'}
} \and
\infer{
  \high R[r] = \mathtt{int}\ i \and
  i \neq 0
}{
  \execis{\high G}
    {\high H, \high R, (\mathtt{beq}\ r, \high v) ; \high I}
    {\high H, \high R, \high I}
} \and
\infer{
  \evalregs{\high R}{\high v}{\high w} \and
  \evalcode{\high G}{\high w}{I}
}{
  \execis{\high G}
    {\high H, \high R, \mathtt{jmp}\ \high v}
    {\high H, \high R, \high I}
}
\end{mathpar}

Additionally we have three judgments on program states:

\fbox{$\halting{\high P}$}
\begin{mathpar}
  \infer{ }{
    \halting{\high G, \high H, \high R, \mathtt{halt}}
  }
\end{mathpar}

\fbox{$\progressing{\high P}$}
\begin{mathpar}
  \infer{
    \steps{\high P}{\high P'}
  }{
    \progressing{\high P}
  }
\end{mathpar}

\fbox{$\goodstate{\high P}$}
\begin{mathpar}
  \infer{
    \halting{\high P}
  }{
    \goodstate{\high P}
  } \and
  \infer{
    \progressing{\high P}
  }{
    \goodstate{\high P}
  }
\end{mathpar}

\subsection{Notes on the Agda implementation}

The file \texttt{Judgments/HighSemantics.agda} is very close in form to this
presentation. We have deviated slightly from this form, as the Agda-version uses
functions for some syntax where the thesis uses premises and vice versa.

\subsection{Lemmas}

It turns out that our small-semantics is deterministic, which implies that it is
a partial function, so the following lemma is proved in the file
\texttt{Lemmas/HighSemantics.agda}.

\begin{lemma}
  \label{lemma:computhigh}
  Our small-step relation for \ATAL is a partial, computable function. Or more
  precisely:

  \begin{itemize}
  \item If $\high P, \high P', \high P''$ are a program states and we have both
    $\steps{\high P}{\high P'}$ and $\steps{\high P}{\high P''}$, then
    $P' = P''$.
  \item It is decidable whether $\high P$ can small-step to some $P'$.
  \end{itemize}

  Similar lemmas exists for the other semantic judgments.
\end{lemma}

\section{Semantics for \ATALe}

The semantics for \ATALe er mostly the same as for \ATAL -- it has the same 5
core judgments as. The difference are:

\begin{itemize}
\item $\evalregs{\simple R}{\simple v}{\simple w}$ has one case less than
  $\evalregs{\high R}{\high v}{\high w}$ because \ATALe does not have the
  instantiation syntax.
\item For the same reason there is one fewer case for
  $\evalcode{\simple G}{\simple w}{\simple I}$. Note that this makes the
  judgment mostly trivial.
\item
  $\execis{\simple G}{\simple H, \simple R, \simple I}{\simple H', \simple R',
    \simple I'}$ has changed slightly. The cases for $\mathtt{ld}\ r_a, r_b(n)$
  and $\mathtt{st}\ r_a(n), r_b$ have been simplified in the obvious way as
  tuples no longer carry type information. The case for $\mathtt{malloc}$ is the
  only one that has a non-trivial change:
\end{itemize}

\begin{mathpar}
\infer{
  \ell_{\mathrm{h}} \notin \mathbf{dom}(\simple H) \and
  \simple h = \mathtt{tuple}\ \overbrace{\langle \mathtt{uninit}, \dots, \mathtt{uninit} \rangle}^n
}{
  \execis{\simple G}
    {\simple H, \simple R, (\mathtt{malloc}\ r, n) ; \simple I}
    {\simple H \cup \{\ell_{\mathrm{h}} |-> \simple h\}, R[r |-> \mathtt{heapval}\ \ell_{\mathrm{h}}], \simple I}
} \and
\end{mathpar}

The full semantics for \ATALe have been included in the appendix.\todo{Where in
  the appendix?}

\subsection{Notes on the Agda implementation}

The file \texttt{Judgments/SimpleSemantics.agda} is again very close in form to
this presentation. We have made the same deviations as we did for \ATAL.

\subsection{Lemmas}

It should be no surprise that this small-step semantics is deterministic, given
that it is mostly the same as for \ATAL. We prove the following lemma in
\texttt{Lemmas/SimpleSemantics.agda}:

\begin{lemma}
  \label{lemma:computsimple}
  Our small-step relation for \ATALe is a partial, computable function. Or more
  precisely:

  \begin{itemize}
  \item If $\simple P, \simple{P'}, \simple{P''}$ are a program states and we
    have both $\steps{\simple P}{\simple{P'}}$ and
    $\steps{\simple P}{\simple{P''}}$, then $P' = P''$.
  \item It is decidable whether $\simple P$ can small-step to some $P'$.
  \end{itemize}

  Similar lemmas exists for the other semantic judgments.
\end{lemma}
